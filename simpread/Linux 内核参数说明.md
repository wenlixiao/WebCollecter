> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/xibuhaohao/p/11120380.html)

**目录**

*   [内核参数列表](#_label0)
*   [内存参数列表](#_label1) 
*   [网络参数列表](#_label2) 
*   [文件系统参数列表](#_label3) 

转载自：

https://www.cnblogs.com/tolimit/p/5065761.html

　　因个人能力有限，不能保证所有描述都正确，还请大家集思广益，有错误的地方欢迎大家留言指正，同时也欢迎大家留言对未标注项进行补偿，谢谢。

[回到顶部](#_labelTop)

内核参数列表
------

<table border="0" cellspacing="0" cellpadding="0"><colgroup><col width="537"><col width="1089"></colgroup><tbody><tr><td width="537" height="90">kernel.acct</td><td width="1089">acct 功能用于系统记录进程信息，正常结束的进程都会在该文件尾添加对应的信息。异常结束是指重启或其它致命的系统问题，不能够记录永不停止的进程。该设置需要配置三个值，分别是：<br>1. 如果文件系统可用空间低于这个百分比值，则停止记录进程信息。<br>2. 如果文件系统可用空间高于这个百分比值，则开始记录进程信息。<br>3. 检查上面两个值的频率 (以秒为单位)。</td></tr><tr><td height="54">kernel.auto_msgmni</td><td width="1089">系统自动设置同时运行的消息队列个数。<br>0：不自动<br>1：自动</td></tr><tr><td height="18">kernel.blk_iopoll</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.cad_pid</td><td width="1089">接收 Ctrl-alt-del 操作的 INT 信号的进程的 PID</td></tr><tr><td height="36">kernel.cap_last_cap</td><td width="1089">系统 capabilities 最高支持的权限等级。<br>详见：http://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html</td></tr><tr><td height="18">kernel.compat-log</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.core_pattern</td><td width="1089">设置 core 文件保存位置或文件名, 只有文件名时，则保存在应用程序运行的目录下</td></tr><tr><td height="54">kernel.core_pipe_limit</td><td width="1089">定义了可以有多少个并发的崩溃程序可以通过管道模式传递给指定的 core 信息收集程序。如果超过了指定数，则后续的程序将不会处理，只在内核日志中做记录。0 是个特殊的值，当设置为 0 时，不限制并行捕捉崩溃的进程，但不会等待用户程序搜集完毕方才回收 / proc/pid 目录（就是说，崩溃程序的相关信息可能随时被回收，搜集的信息可能不全）。</td></tr><tr><td height="54">kernel.core_uses_pid</td><td width="1089">Core 文件的文件名是否添加应用程序 pid 做为扩展<br>0：不添加<br>1：添加</td></tr><tr><td height="54">kernel.ctrl-alt-del</td><td width="1089">该值控制系统在接收到 ctrl+alt+delete 按键组合时如何反应：<br>1：不捕获 ctrl-alt-del，将系统类似于直接关闭电源<br>0：捕获 ctrl-alt-del，并将此信号传至 cad_pid 保存的 PID 号进程进行处理</td></tr><tr><td height="54">kernel.dmesg_restrict</td><td width="1089">限制哪些用户可以查看 syslog 日志<br>0：不限制<br>1：只有特权用户能够查看</td></tr><tr><td height="18">kernel.domainname</td><td width="1089">网络域名 (重启失效)</td></tr><tr><td height="54">kernel.ftrace_dump_on_oops</td><td width="1089">确定是否将 ftrace 的缓冲区的信息打印出来，是通过 printk 来打印的<br>0：不打印<br>1：在系统 oops 时，自动 dump 堆栈信息到输出终端</td></tr><tr><td height="18">kernel.hostname</td><td width="1089">主机名 (重启失效)</td></tr><tr><td height="18">kernel.hotplug</td><td width="1089">该文件给出了当前系统支持热插拔 (hotplug) 时接收热插拔事件的程序的名字（包括路径）。</td></tr><tr><td height="54">kernel.hung_task_check_count</td><td width="1089">hung_task 检查的进程数量最大值<br>hung_task 用于检测一个进程是否在 TASK_UNINTERRUPTIBLE 状态过长，只有在等待 IO 的时候进程才会处于 TASK_UNINTERRUPTIBLE 状态，这个状态的进程内核不能够通过信号将其唤醒并杀死。</td></tr><tr><td height="54">kernel.hung_task_panic</td><td width="1089">设置 hung_task 发生后是否引发 panic<br>1：触发<br>0：不触发</td></tr><tr><td height="36">kernel.hung_task_timeout_secs</td><td width="1089">hung_task 超时时间 (以秒为单位)，当一个进程在 TASK_UNINTERRUPTIBLE 状态超过这个时间后，会发生一个 hung_task<br>linux 会设置 40% 的可用内存用来做系统 cache，当 flush 数据时这 40% 内存中的数据由于和 IO 同步问题导致超时。</td></tr><tr><td height="18">kernel.hung_task_warnings</td><td width="1089">最大产生警告数量，当发生一次 hung_task 时会产生一次警告，但警告数量到达此值后之后的 hung_task 就不会发生警告</td></tr><tr><td height="54">kernel.kexec_load_disabled</td><td width="1089">表示 kexec_load 系统调用是否被禁止，此系统调用用于 kdump。当发生了一次 kexec_load 后，此值会自动设置为 1。<br>0：开启 kexec_load 系统调用<br>1：禁止 kexec_load 系统调用</td></tr><tr><td height="18">kernel.keys.gc_delay</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.keys.maxbytes</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.keys.maxkeys</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.keys.persistent_keyring_expiry</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.keys.root_maxbytes</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.keys.root_maxkeys</td><td width="1089">&nbsp;</td></tr><tr><td height="126">kernel.kptr_restrict</td><td width="1089">是否启用 kptr_restrice，此功能为安全性功能，用于屏蔽内核指针。<br>0：该特性被完全禁止;<br>1：那些使用 “%pk” 打印出来的内核指针被隐藏(会以一长串 0 替换掉)，除非用户有 CAP_SYSLOG 权限，并且没有改变他们的 UID/GID(防止在撤销权限之前打开的文件泄露指针信息);<br>2：所有内核指使用 “%pk” 打印的都被隐藏。</td></tr><tr><td height="18">kernel.max_lock_depth</td><td width="1089">触发死锁检查的嵌套深度值</td></tr><tr><td height="18">kernel.modprobe</td><td width="1089">该文件给出了当系统支持 module 时完成 modprobe 功能的程序的名字（包括路径）。</td></tr><tr><td height="54">kernel.modules_disabled</td><td width="1089">表示是否禁止内核运行时可加载模块<br>0：不禁止<br>1：禁止</td></tr><tr><td height="18">kernel.msgmax</td><td width="1089">消息队列中单个消息的最大字节数</td></tr><tr><td height="18">kernel.msgmnb</td><td width="1089">单个消息队列中允许的最大字节长度 (限制单个消息队列中所有消息包含的字节数之和)</td></tr><tr><td height="18">kernel.msgmni</td><td width="1089">系统中同时运行的消息队列的个数</td></tr><tr><td height="18">kernel.ngroups_max</td><td width="1089">每个用户最大的组数</td></tr><tr><td height="54">kernel.nmi_watchdog</td><td width="1089">使能 nmi_watchdog<br>0：禁止<br>1：开启</td></tr><tr><td height="18">kernel.numa_balancing</td><td width="1089">是否开启 numa_balancing？这块具体看代码</td></tr><tr><td height="18">kernel.numa_balancing_scan_delay_ms</td><td width="1089">单个进程每次进行 numa_balancing 扫描的间隔时间</td></tr><tr><td height="18">kernel.numa_balancing_scan_period_max_ms</td><td width="1089">每次扫描最多花费的时间？</td></tr><tr><td height="18">kernel.numa_balancing_scan_period_min_ms</td><td width="1089">每次扫描最少花费的时间？</td></tr><tr><td height="18">kernel.numa_balancing_scan_size_mb</td><td width="1089">一次扫描进程多少 MB 的虚拟地址空间内存</td></tr><tr><td height="18">kernel.numa_balancing_settle_count</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.osrelease</td><td width="1089">内核版本 (例：3.10.0-229.7.2.rs1.2.ppc64)</td></tr><tr><td height="18">kernel.ostype</td><td width="1089">操作系统的类型 (例：Linux)</td></tr><tr><td height="18">kernel.overflowgid</td><td width="1089">Linux 的 GID 为 32 位，但有些文件系统只支持 16 位的 GID，此时若进行写操作会出错；当 GID 超过 65535 时会自动被转换为一个固定值，这个固定值保存在这个文件中</td></tr><tr><td height="18">kernel.overflowuid</td><td width="1089">Linux 的 UID 为 32 位，但有些文件系统只支持 16 位的 UID，此时若进行写操作会出错；当 UID 超过 65535 时会自动被转换为一个固定值，这个固定值保存在这个文件中</td></tr><tr><td height="54">kernel.panic</td><td width="1089">系统发生 panic 时内核重新引导之前的等待时间<br>0：禁止重新引导<br>&gt;0：重新引导前的等待时间 (秒)</td></tr><tr><td height="54">kernel.panic_on_oops</td><td width="1089">当系统发生 oops 或 BUG 时，所采取的措施<br>0：继续运行<br>1：让 klog 记录 oops 的输出，然后 panic，若 kernel.panic 不为 0，则等待后重新引导内核</td></tr><tr><td height="36">kernel.panic_on_warn</td><td width="1089">0：只警告，不发生 panic<br>1：发生 panic</td></tr><tr><td height="54">kernel.perf_cpu_time_max_percent</td><td width="1089">perf 分析工具最大能够占用 CPU 性能的百分比<br>0：不限制<br>1~100：百分比值</td></tr><tr><td height="18">kernel.perf_event_max_sample_rate</td><td width="1089">设置 perf_event 的最大取样速率，默认值为 100000</td></tr><tr><td height="18">kernel.perf_event_mlock_kb</td><td width="1089">设置非特权用户能够允许常驻内存的内存大小。默认为 516(KB)</td></tr><tr><td height="90">kernel.perf_event_paranoid</td><td width="1089">用于限制访问性能计数器的权限<br>0：仅允许访问用户空间的性能计数器<br>1：内核与用户空间的性能计数器都可以访问<br>2：仅允许访问特殊的 CPU 数据 (不包括跟踪点)<br>-1：不限制</td></tr><tr><td height="18">kernel.pid_max</td><td width="1089">进程 pid 号的最大值</td></tr><tr><td height="18">kernel.poweroff_cmd</td><td width="1089">执行关机命令的进程 (包括路径)</td></tr><tr><td height="54">kernel.powersave-nap</td><td width="1089">PPC 专用，如果开启，则使用 nap 节能模式，关闭则使用 doze 节能模式<br>0：关闭<br>1：开启</td></tr><tr><td height="18">kernel.print-fatal-signals</td><td width="1089">&nbsp;</td></tr><tr><td height="108">kernel.printk</td><td width="1089">该文件有四个数字值，它们根据日志记录消息的重要性，定义将其发送到何处。按顺序是：<br>1. 控制台日志级别：优先级高于该值的消息将被打印至控制台<br>2. 默认的消息日志级别：将用该优先级来打印没有优先级的消息<br>3. 最低的控制台日志级别：控制台日志级别可被设置的最小值 (最高优先级)<br>4. 默认的控制台日志级别：控制台日志级别的缺省值<br>数值越小，优先级越高，级别有 (0~7)</td></tr><tr><td height="18">kernel.printk_delay</td><td width="1089">printk 消息之间的延迟毫秒数，此值不可设置</td></tr><tr><td height="36">kernel.printk_ratelimit</td><td width="1089">等待允许再次 printk 的时间 (以秒为单位)，与 printk_ratelimit() 函数有关<br>详见：http://m.blog.csdn.net/blog/chenglinhust/8599159</td></tr><tr><td height="36">kernel.printk_ratelimit_burst</td><td width="1089">printk 的缓存队列长度 (每个 printk 为一个长度，比如此值为 5，而有段代码是连续 printk10 次，系统的处理是先 printk 前 5 次，等待 printk_ratelimit 秒后，再打印后面 5 次)</td></tr><tr><td height="18">kernel.pty.max</td><td width="1089">所能分配的 PTY 的最多个数 (pty 为虚拟终端，用于远程连接时)</td></tr><tr><td height="18">kernel.pty.nr</td><td width="1089">当前分配的 pty 的个数</td></tr><tr><td height="18">kernel.pty.reserve</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.random.boot_id</td><td width="1089">此文件是个只读文件，包含了一个随机字符串，在系统启动的时候会自动生成这个 uuid</td></tr><tr><td height="18">kernel.random.entropy_avail</td><td width="1089">此文件是个只读文件，给出了一个有效的熵 (4096 位)</td></tr><tr><td height="18">kernel.random.poolsize</td><td width="1089">熵池大小，一般是 4096 位，可以改成任何大小</td></tr><tr><td height="18">kernel.random.read_wakeup_threshold</td><td width="1089">该文件保存熵的长度，该长度用于唤醒因读取 / dev/random 设备而待机的进程 (random 设备的读缓冲区长度？)</td></tr><tr><td height="18">kernel.random.uuid</td><td width="1089">此文件是个只读文件，包含了一个随机字符串，在 random 设备每次被读的时候生成</td></tr><tr><td height="18">kernel.random.write_wakeup_threshold</td><td width="1089">该文件保存熵的长度，该长度用于唤醒因写入 / dev/random 设备而待机的进程 (random 设备的写缓冲区长度？)</td></tr><tr><td height="90">kernel.randomize_va_space</td><td width="1089">用于设置进程虚拟地址空间的随机化<br>0：关闭进程虚拟地址空间随机化<br>1：随机化进程虚拟地址空间中的 mmap 映射区的初始地址，栈空间的初始地址以及 VDSO 页的地址<br>2：在 1 的基础上加上堆区的随机化<br>(VDSO 是用于兼容不同内核与 glibc 的接口的机制)</td></tr><tr><td height="18">kernel.real-root-dev</td><td width="1089">根文件系统所在的设备 (写入格式是 0x 主设备号(16 位) 次设备号(16 位)，例如 0x801，主设备号是 8，次设备号是 1)，只有使用 initrd.img 此参数才有效</td></tr><tr><td height="54">kernel.sched_autogroup_enabled</td><td width="1089">启用后，内核会创建任务组来优化桌面程序的调度。它将把占用大量资源的应用程序放在它们自己的任务组，这有助于性能提升<br>0：禁止<br>1：开启</td></tr><tr><td height="18">kernel.sched_cfs_bandwidth_slice_us</td><td width="1089">&nbsp;</td></tr><tr><td height="54">kernel.sched_child_runs_first</td><td width="1089">设置保证子进程初始化完成后在父进程之前先被调度<br>0：先调度父进程<br>1：先调度子进程</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.busy_factor</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.busy_idx</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.cache_nice_tries</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.flags</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.forkexec_idx</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.idle_idx</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.imbalance_pct</td><td width="1089">判断该调度域是否已经均衡的一个基准值</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.max_interval</td><td width="1089">设置此 CPU 进行负载均衡的最长间隔时间，上一次做了负载均衡经过了这个时间一定要再进行一次</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.min_interval</td><td width="1089">设置此 CPU 进行负载均衡的最小间隔时间，在上一次负载均衡到这个时间内都不能再进行负载均衡</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.name</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.newidle_idx</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_domain.{CPUID}.{域 ID}.wake_idx</td><td width="1089">&nbsp;</td></tr><tr><td height="36">kernel.sched_latency_ns</td><td width="1089">表示正在运行进程的所能运行的时间的最大值，即使只有一个处于 running 状态的进程，运行到这个时间也要重新调度一次 (以纳秒为单位，在运行时会自动变化？)<br>同时这个值也是所有可运行进程都运行一次所需的时间，每个 CPU 的 running 进程数 = sched_latency_ns / sched_min_granularity_ns</td></tr><tr><td height="36">kernel.sched_migration_cost_ns</td><td width="1089">该变量用来判断一个进程是否还是 hot，如果进程的运行时间（now - p-&gt;se.exec_start）小于它，那么内核认为它的 code 还在 cache 里，所以该进程还是 hot，那么在迁移的时候就不会考虑它</td></tr><tr><td height="18">kernel.sched_min_granularity_ns</td><td width="1089">表示一个进程在 CPU 上运行的最小时间，在此时间内，内核是不会主动挑选其他进程进行调度 (以纳秒为单位，在运行时会自动变化？)</td></tr><tr><td height="18">kernel.sched_nr_migrate</td><td width="1089">在多 CPU 情况下进行负载均衡时，一次最多移动多少个进程到另一个 CPU 上</td></tr><tr><td height="18">kernel.sched_rr_timeslice_ms</td><td width="1089">用来指示 round robin 调度进程的间隔，这个间隔默认是 100ms。</td></tr><tr><td height="18">kernel.sched_rt_period_us</td><td width="1089">该参数与 sched_rt_runtime_us 一起决定了实时进程在以 sched_rt_period 为周期的时间内，实时进程最多能够运行的总的时间不能超过 sched_rt_runtime_us</td></tr><tr><td height="18">kernel.sched_rt_runtime_us</td><td width="1089">该参数与 sched_rt_period 一起决定了实时进程在以 sched_rt_period 为周期的时间内，实时进程最多能够运行的总的时间不能超过 sched_rt_runtime_us</td></tr><tr><td height="18">kernel.sched_shares_window_ns</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.sched_time_avg_ms</td><td width="1089">&nbsp;</td></tr><tr><td height="72">kernel.sched_tunable_scaling</td><td width="1089">当内核试图调整 sched_min_granularity，sched_latency 和 sched_wakeup_granularity 这三个值的时候所使用的更新方法.<br>0：不调整<br>1：按照 cpu 个数以 2 为底的对数值进行调整<br>2：按照 cpu 的个数进行线性比例的调整</td></tr><tr><td height="36">kernel.sched_wakeup_granularity_ns</td><td width="1089">该变量表示进程被唤醒后至少应该运行的时间的基数，它只是用来判断某个进程是否应该抢占当前进程，并不代表它能够执行的最小时间（sysctl_sched_min_granularity），如果这个数值越小，那么发生抢占的概率也就越高</td></tr><tr><td height="108">kernel.sem</td><td width="1089">该文件包含 4 个值：<br>1. 同一类信号的最多数量 (semmsl)<br>2. 系统中信号的最多数目，=semmni*semmsl (semmns)<br>3. 每个 semop 系统调用所包含的最大的操作数 (能调用的信号量的最多次数) (semopm)<br>4. 系统中信号类型的数目的最大值，一个信号量标识符代表一个类型 (semmni)<br>可见：http://www.cnblogs.com/jimeper/p/3141975.html</td></tr><tr><td height="18">kernel.shmall</td><td width="1089">系统上可以使用的共享内存的总量（以字节为单位）。</td></tr><tr><td height="18">kernel.shmmax</td><td width="1089">系统所允许的最大共享内存段的大小（以字节为单位）。</td></tr><tr><td height="18">kernel.shmmni</td><td width="1089">整个系统共享内存段的最大数量。&nbsp;</td></tr><tr><td height="54">kernel.shm_rmid_forced</td><td width="1089">强制 SHM 空间和一个进程联系在一起，所以可以通过杀死进程来释放内存<br>0：不设置<br>1：设置</td></tr><tr><td height="72">kernel.softlockup_panic</td><td width="1089">设置产生 softlockup 时是否抛出一个 panic。Softlockup 用于检测 CPU 可以响应中断，但是在长时间内不能调度（比如禁止抢占时间太长）的死锁情况。这个机制运行在一个 hrtimer 的中断上下文，每隔一段时间检测一下是否发生了调度，如果过长时间没发生调度，说明系统被死锁。<br>0：不产生 panic<br>1：产生 panic</td></tr><tr><td height="36">kernel.sysrq</td><td width="1089">该文件指定的值为非零，则激活键盘上的 sysrq 按键。这个按键用于给内核传递信息，用于紧急情况下重启系统。当遇到死机或者没有响应的时候，甚至连 tty 都进不去，可以尝试用 SysRq 重启计算机。</td></tr><tr><td height="36">kernel.tainted</td><td width="1089">1：加载非 GPL module<br>0：强制加载 module&nbsp;</td></tr><tr><td height="18">kernel.threads-max</td><td width="1089">系统中进程数量 (包括线程) 的最大值</td></tr><tr><td height="18">kernel.timer_migration</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.usermodehelper.bset</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.usermodehelper.inheritable</td><td width="1089">&nbsp;</td></tr><tr><td height="18">kernel.version</td><td width="1089">版本号 (例：#1 SMP Mon Sep 7 18:12:36 CST 2015)</td></tr><tr><td height="54">kernel.watchdog</td><td width="1089">表示是否禁止 softlockup 模式和 nmi_watchdog(softlockup 用于唤醒 watchdog)<br>0：禁止<br>1：开启</td></tr><tr><td height="36">kernel.watchdog_thresh</td><td width="1089">用于设置高精度定时器 (hrtimer)、nmi 事件、softlockup、hardlockup 的阀值 (以秒为单位)<br>0：不设置阀值</td></tr></tbody></table>

[回到顶部](#_labelTop)

内存参数列表 
-------

<table border="0" cellspacing="0" cellpadding="0"><colgroup><col width="262"><col width="1500"></colgroup><tbody><tr><td width="262" height="18">vm.admin_reserve_kbytes</td><td width="1500">给有 cap_sys_admin 权限的用户保留的内存数量 (默认值是 min(free_page * 0.03, 8MB))</td></tr><tr><td height="18">vm.block_dump</td><td width="1500">如果设置的是非零值，则会启用块 I/O 调试。</td></tr><tr><td height="36">vm.compact_memory</td><td width="1500">进行内存压缩，只有在启用了 CONFIG_COMPACTION 选项才有效<br>1：开始进行内存压缩</td></tr><tr><td height="18">vm.dirty_background_bytes</td><td width="1500">当脏页所占的内存数量超过 dirty_background_bytes 时，内核的 flusher 线程开始回写脏页。</td></tr><tr><td height="18">vm.dirty_background_ratio</td><td width="1500">当脏页所占的百分比（相对于所有可用内存，即空闲内存页 + 可回收内存页）达到 dirty_background_ratio 时，write 调用会唤醒内核的 flusher 线程开始回写脏页数据，直到脏页比例低于此值，与 dirty_ratio 不同，write 调用此时并不会阻塞。</td></tr><tr><td height="36">vm.dirty_bytes</td><td width="1500">当脏页所占的内存数量达到 dirty_bytes 时，执行磁盘写操作的进程自己开始回写脏数据。<br>注意： dirty_bytes 参数和 dirty_ratio 参数是相对的，只能指定其中一个。当其中一个参数文件被写入时，会立即开始计算脏页限制，并且会将另一个参数的值清零</td></tr><tr><td height="18">vm.dirty_expire_centisecs</td><td width="1500">脏数据的过期时间，超过该时间后内核的 flusher 线程被唤醒时会将脏数据回写到磁盘上，单位是百分之一秒。</td></tr><tr><td height="18">vm.dirty_ratio</td><td width="1500">脏页所占的百分比（相对于所有可用内存，即空闲内存页 + 可回收内存页）达到 dirty_ratio 时，write 调用会唤醒内核的 flusher 线程开始回写脏页数据，直到脏页比例低于此值，注意 write 调用此时会阻塞。</td></tr><tr><td height="18">vm.dirty_writeback_centisecs</td><td width="1500">设置 flusher 内核线程唤醒的间隔，此线程用于将脏页回写到磁盘，单位是百分之一秒</td></tr><tr><td height="72">vm.drop_caches</td><td width="1500">写入数值可以使内核释放 page_cache，dentries 和 inodes 缓存所占的内存。<br>1：只释放 page_cache<br>2：只释放 dentries 和 inodes 缓存<br>3：释放 page_cache、dentries 和 inodes 缓存</td></tr><tr><td height="18">vm.extfrag_threshold</td><td width="1500">&nbsp;</td></tr><tr><td height="36">vm.hugepages_treat_as_movable</td><td width="1500">用来控制是否可以从 ZONE_MOVABLE 内存域中分配大页面。如果设置为非零，大页面可以从 ZONE_MOVABLE 内存域分配。ZONE_MOVABLE 内存域只有在指定了 kernelcore 启动参数的情况下才会创建，如果没有指定 kernelcore 启动参数， hugepages_treat_as_movable 参数则没有效果。</td></tr><tr><td height="18">vm.hugetlb_shm_group</td><td width="1500">指定组 ID，拥有该 gid 的用户可以使用大页创建 SysV 共享内存段</td></tr><tr><td height="54">vm.laptop_mode</td><td width="1500">设置开启 laptop mode，此模式主要是通过降低硬盘的转速来延长电池的续航时间。<br>0：关闭<br>1：启动</td></tr><tr><td height="72">vm.legacy_va_layout</td><td width="1500">进程地址空间内存布局模式<br>0：经典布局<br>1：新布局<br>对于 64 位系统，默认采用经典布局</td></tr><tr><td height="18">vm.lowmem_reserve_ratio</td><td width="1500">决定了内核保护这些低端内存域的强度。预留的内存值和 lowmem_reserve_ratio 数组中的值是倒数关系，如果值是 256，则代表 1/256，即为 0.39% 的 zone 内存大小。如果想要预留更多页，应该设更小一点的值。</td></tr><tr><td height="18">vm.max_map_count</td><td width="1500">定义了一个进程能拥有的最多的内存区域</td></tr><tr><td height="54">vm.memory_failure_early_kill</td><td width="1500">控制发生某个内核无法处理的内存错误发生的时候，如何去杀掉这个进程。当这些错误页有 swap 镜像的时候，内核会很好的处理这个错误，不会影响任何应用程序，但是如果没有的话，内核会把进程杀掉，避免内存错误的扩大<br>1：在发现内存错误的时候，就会把所有拥有此内存页的进程都杀掉<br>0：只是对这部分页进行 unmap，然后把第一个试图进入这个页的进程杀掉</td></tr><tr><td height="54">vm.memory_failure_recovery</td><td width="1500">是否开启内存错误恢复机制<br>1：开启<br>0：一旦出现内存错误，就 panic</td></tr><tr><td height="18">vm.min_free_kbytes</td><td width="1500">每个内存区保留的内存大小 (以 KB 计算)</td></tr><tr><td height="36">vm.min_slab_ratio</td><td width="1500">只在 numa 架构上使用，如果一个内存域中可以回收的 slab 页面所占的百分比（应该是相对于当前内存域的所有页面）超过 min_slab_ratio，在回收区的 slabs 会被回收。这样可以确保即使在很少执行全局回收的 NUMA 系统中，slab 的增长也是可控的。</td></tr><tr><td height="18">vm.min_unmapped_ratio</td><td width="1500">只有在当前内存域中处于 zone_reclaim_mode 允许回收状态的内存页所占的百分比超过 min_unmapped_ratio 时，内存域才会执行回收操作。</td></tr><tr><td height="36">vm.mmap_min_addr</td><td width="1500">指定用户进程通过 mmap 可使用的最小虚拟内存地址，以避免其在低地址空间产生映射导致安全问题；如果非 0，则不允许 mmap 到 NULL 页，而此功能可在出现 NULL 指针时调试 Kernel；mmap 用于将文件映射至内存；<br>该设置意味着禁止用户进程访问 low 4k 地址空间</td></tr><tr><td height="18">vm.nr_hugepages</td><td width="1500">大页的最小数目，需要连续的物理内存；oracle 使用大页可以降低 TLB 的开销，节约内存和 CPU 资源，但要同时设置 memlock 且保证其大于大页；其与 11gAMM 不兼容</td></tr><tr><td height="18">vm.nr_hugepages_mempolicy</td><td width="1500">与 nr_hugepages 类似，但只用于 numa 架构，配合 numactl 调整每个 node 的大页数量</td></tr><tr><td height="18">vm.nr_overcommit_hugepages</td><td width="1500">保留于紧急使用的大页数，系统可分配最大大页数 = nr_hugepages + nr_overcommit_hugepages</td></tr><tr><td height="18">vm.nr_pdflush_threads</td><td width="1500">只读文件，保存了当前正在运行的 pdflush 线程的数量</td></tr><tr><td height="72">vm.numa_zonelist_order</td><td width="1500">设置内核选择 zonelist 的模式：<br>0：让内核智能选择使用 Node 或 Zone 方式的 zonelist<br>1：选择 Node 方式的 zonelist，Node(0) ZONE_NORMAL -&gt; Node(0) ZONE_DMA -&gt; Node(1) ZONE_NORMAL<br>2：选择 Zone 方式的，Node(0) ZONE_NORMAL -&gt; Node(1) ZONE_NORMAL -&gt; Node(0) ZONE_DMA</td></tr><tr><td height="72">vm.oom_dump_tasks</td><td width="1500">如果启用，在内核执行 OOM-killing 时会打印系统内进程的信息（不包括内核线程），信息包括 pid、uid、tgid、vm size、rss、nr_ptes，swapents，oom_score_adj 和进程名称。这些信息可以帮助找出为什么 OOM killer 被执行，找到导致 OOM 的进程，以及了解为什么进程会被选中。<br>0：不打印系统内进程信息<br>1：打印系统内进程信息</td></tr><tr><td height="54">vm.oom_kill_allocating_task</td><td width="1500">决定在 oom 的时候，oom killer 杀哪些进程<br>非 0：它会扫描进程队列，然后将可能导致内存溢出的进程杀掉，也就是占用内存最大的进程<br>0：它只杀掉导致 oom 的那个进程，避免了进程队列的扫描，但是释放的内存大小有限</td></tr><tr><td height="18">vm.overcommit_kbytes</td><td width="1500">内存可过量分配的数量 (单位为 KB)</td></tr><tr><td height="90">vm.overcommit_memory</td><td width="1500">是否允许内存的过量分配，允许进程分配比它实际使用的更多的内存。<br>0：当用户申请内存的时候，内核会去检查是否有这么大的内存空间，当超过地址空间会被拒绝<br>1：内核始终认为，有足够大的内存空间，直到它用完了位置<br>2：内核禁止任何形式的过量分配内存<br>Memory allocation limit = swapspace + physmem * (overcommit_ratio / 100)</td></tr><tr><td height="18">vm.overcommit_ratio</td><td width="1500">内存可过量分配的百分比。</td></tr><tr><td height="18">vm.page-cluster</td><td width="1500">参数控制一次写入或读出 swap 分区的页面数量。它是一个对数值，如果设置为 0，表示 1 页；如果设置为 1，表示 2 页；如果设置为 2，则表示 4 页。</td></tr><tr><td height="72">vm.panic_on_oom</td><td width="1500">用于控制如何处理 out-of-memory，可选值包括 0/1/2<br>0：当内存不足时内核调用 OOM killer 杀死一些 rogue 进程，每个进程描述符都有一个 oom_score 标示，oom killer 会选择 oom_score 较大的进程<br>1：发生了 OOM 以后，如果有 mempolicy/cpusets 的进程限制，而这些 nodes 导致了内存问题的时候，OOM Killer 会干掉这些中的一个，系统也会恢复<br>2：OOM 后必然 panic</td></tr><tr><td height="18">vm.percpu_pagelist_fraction</td><td width="1500">每个 CPU 能从每个 zone 所能分配到的 pages 的最大值 (单位每个 zone 的 1/X)，0 为不限制</td></tr><tr><td height="18">vm.stat_interval</td><td width="1500">VM 信息更新频率 (以秒为单位)</td></tr><tr><td height="18">vm.swappiness</td><td width="1500">该值越高则 linux 越倾向于将部分长期没有用到的页 swap，即便有足够空余物理内存 (1~100)</td></tr><tr><td height="18">vm.user_reserve_kbytes</td><td width="1500">&nbsp;</td></tr><tr><td height="36">vm.vfs_cache_pressure</td><td width="1500">表示内核回收用于 directory 和 inode cache 内存的倾向；缺省值 100 表示内核将根据 pagecache 和 swapcache，把 directory 和 inode cache 保持在一个合理的百分比；降低该值低于 100，将导致内核倾向于保留 directory 和 inode cache；增加该值超过 100，将导致内核倾向于回收 directory 和 inode cache</td></tr><tr><td height="90">vm.zone_reclaim_mode</td><td width="1500">参数只有在启用 CONFIG_NUMA 选项时才有效, zone_reclaim_mode 用来控制在内存域 OOM 时，如何来回收内存。<br>0：禁止内存域回收，从其他 zone 分配内存<br>1：启用内存域回收<br>2：通过回写脏页回收内存<br>4：通过 swap 回收内存</td></tr></tbody></table>

[回到顶部](#_labelTop)

网络参数列表 
-------

<table border="0" cellspacing="0" cellpadding="0"><colgroup><col width="537"><col width="1100"></colgroup><tbody><tr><td width="537" height="18">net.bridge.bridge-nf-call-arptables</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.bridge.bridge-nf-call-ip6tables</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.bridge.bridge-nf-call-iptables</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.bridge.bridge-nf-filter-pppoe-tagged</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.bridge.bridge-nf-filter-vlan-tagged</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.bridge.bridge-nf-pass-vlan-input-dev</td><td width="1100">&nbsp;</td></tr><tr><td height="90">net.core.bpf_jit_enable</td><td width="1100">基于时间规则的编译器，用于基于 PCAP（packet capture library）并使用伯克利包过滤器（Berkeley Packet Filter，如 tcpdump）的用户工具，可以大幅提升复杂规则的处理性能。<br>0：禁止<br>1：开启<br>2：开启并请求编译器将跟踪数据时间写入内核日志</td></tr><tr><td height="18">net.core.busy_poll</td><td width="1100">默认对网络设备进行 poll 和 select 操作的超时时间 (us)，具体数值最好以 sockets 数量而定</td></tr><tr><td height="18">net.core.busy_read</td><td width="1100">默认读取在设备帧队列上数据帧的超时时间 (us)，推荐值：50</td></tr><tr><td height="18">net.core.default_qdisc</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.core.dev_weight</td><td width="1100">每个 CPU 一次 NAPI 中断能够处理网络包数量的最大值</td></tr><tr><td height="18">net.core.message_burst</td><td width="1100">设置每十秒写入多少次请求警告；此设置可以用来防止 DOS 攻击</td></tr><tr><td height="18">net.core.message_cost</td><td width="1100">设置每一个警告的度量值，缺省为 5，当用来防止 DOS 攻击时设置为 0</td></tr><tr><td height="18">net.core.netdev_budget</td><td width="1100">每次软中断处理的网络包个数</td></tr><tr><td height="18">net.core.netdev_max_backlog</td><td width="1100">设置当个别接口接收包的速度快于内核处理速度时允许的最大的包序列</td></tr><tr><td height="36">net.core.netdev_tstamp_prequeue</td><td width="1100">0：关闭，接收的数据包的时间戳在 RPS 程序处理之后进行标记，这样有可能时间戳会不够准确<br>1：打开，时间戳会尽可能早的标记</td></tr><tr><td height="18">net.core.optmem_max</td><td width="1100">表示每个 socket 所允许的最大缓冲区的大小 (字节)</td></tr><tr><td height="18">net.core.rmem_default</td><td width="1100">设置接收 socket 的缺省缓存大小 (字节)</td></tr><tr><td height="18">net.core.rmem_max</td><td width="1100">设置接收 socket 的最大缓存大小 (字节)</td></tr><tr><td height="18">net.core.rps_sock_flow_entries</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.core.somaxconn</td><td width="1100">定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数。</td></tr><tr><td height="18">net.core.warnings</td><td width="1100">已经不使用此参数</td></tr><tr><td height="18">net.core.wmem_default</td><td width="1100">设置发送的 socket 缺省缓存大小 (字节)</td></tr><tr><td height="18">net.core.wmem_max</td><td width="1100">设置发送的 socket 最大缓存大小 (字节)</td></tr><tr><td height="18">net.core.xfrm_acq_expires</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.core.xfrm_aevent_etime</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.core.xfrm_aevent_rseqth</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.core.xfrm_larval_drop</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.cipso_cache_bucket_size</td><td width="1100">限制 cipso 缓存项的数量，如果在缓存中新添加一行超出了这个限制，那么最旧的缓存项会被丢弃以释放出空间。</td></tr><tr><td height="54">net.ipv4.cipso_cache_enable</td><td width="1100">是否启用 cipso 缓存。<br>0：不启用<br>1：启用</td></tr><tr><td height="54">net.ipv4.cipso_rbm_optfmt</td><td width="1100">是否开启 cipso 标志优化选项，如果开启，数据包中标志将会在 32bit 对齐<br>0：关闭<br>1：开启</td></tr><tr><td height="54">net.ipv4.cipso_rbm_strictvalid</td><td width="1100">是否开启 cipso 选项的严格检测<br>0：不开启<br>1：开启</td></tr><tr><td height="54">net.ipv4.conf.all.accept_local</td><td width="1100">设置是否允许接收从本机 IP 地址上发送给本机的数据包<br>0：不允许<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.all.accept_redirects</td><td width="1100">收发接收 ICMP 重定向消息。对于主机来说默认为 True，对于用作路由器时默认值为 False<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.all.accept_source_route</td><td width="1100">接收带有 SRR 选项的数据报。主机设为 0，路由设为 1</td></tr><tr><td height="54">net.ipv4.conf.all.arp_accept</td><td width="1100">默认对不在 ARP 表中的 IP 地址发出的 APR 包的处理方式<br>0：不在 ARP 表中创建对应 IP 地址的表项<br>1：在 ARP 表中创建对应 IP 地址的表项</td></tr><tr><td height="108">net.ipv4.conf.all.arp_announce</td><td width="1100">对网络接口上，本地 IP 地址的发出的，ARP 回应，作出相应级别的限制: 确定不同程度的限制, 宣布对来自本地源 IP 地址发出 Arp 请求的接口<br>0： 在任意网络接口（eth0,eth1，lo）上的任何本地地址<br>1：尽量避免不在该网络接口子网段的本地地址做出 arp 回应. 当发起 ARP 请求的源 IP 地址是被设置应该经由路由达到此网络接口的时候很有用. 此时会检查来访 IP 是否为所有接口上的子网段内 ip 之一. 如果改来访 IP 不属于各个网络接口上的子网段内, 那么将采用级别 2 的方式来进行处理.<br>2：对查询目标使用最适当的本地地址. 在此模式下将忽略这个 IP 数据包的源地址并尝试选择与能与该地址通信的本地地址. 首要是选择所有的网络接口的子网中外出访问子网中包含该目标 IP 地址的本地地址. 如果没有合适的地址被发现, 将选择当前的发送网络接口或其他的有可能接受到该 ARP 回应的网络接口来进行发送.</td></tr><tr><td height="72">net.ipv4.conf.all.arp_filter</td><td width="1100">0：内核设置每个网络接口各自应答其地址上的 arp 询问。这项看似会错误的设置却经常能非常有效，因为它增加了成功通讯的机会。在 Linux 主机上，每个 IP 地址是网络接口独立的，而非一个复合的接口。只有在一些特殊的设置的时候，比如负载均衡的时候会带来麻烦。<br>1：允许多个网络介质位于同一子网段内，每个网络界面依据是否内核指派路由该数据包经过此接口来确认是否回答 ARP 查询 (这个实现是由来源地址确定路由的时候决定的), 换句话说，允许控制使用某一块网卡（通常是第一块）回应 arp 询问。</td></tr><tr><td height="108">net.ipv4.conf.all.arp_ignore</td><td width="1100">定义对目标地址为本地 IP 的 ARP 询问不同的应答模式<br>0：回应任何网络接口上对任何本地 IP 地址的 arp 查询请求<br>1：只回答目标 IP 地址是来访网络接口本地地址的 ARP 查询请求<br>2：只回答目标 IP 地址是来访网络接口本地地址的 ARP 查询请求, 且来访 IP 必须在该网络接口的子网段内<br>3：不回应该网络界面的 arp 请求，而只对设置的唯一和连接地址做出回应<br>8：不回应所有（本地地址）的 arp 查询</td></tr><tr><td height="54">net.ipv4.conf.all.arp_notify</td><td width="1100">arp 通知链操作<br>0：不做任何操作<br>1：当设备或硬件地址改变时自动产生一个 arp 请求</td></tr><tr><td height="54">net.ipv4.conf.all.bootp_relay</td><td width="1100">接收源地址为 0.a.b.c，目的地址不是本机的数据包，是为了支持 bootp 服务<br>0：关闭<br>1：开启</td></tr><tr><td height="54">net.ipv4.conf.all.disable_policy</td><td width="1100">禁止 internet 协议安全性验证<br>0：禁止禁止<br>1：开启禁止</td></tr><tr><td height="54">net.ipv4.conf.all.disable_xfrm</td><td width="1100">禁止 internet 协议安全性加密<br>0：禁止禁止<br>1：开启禁止</td></tr><tr><td height="18">net.ipv4.conf.all.force_igmp_version</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.conf.all.forwarding</td><td width="1100">在该接口打开转发功能<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.all.log_martians</td><td width="1100">记录带有不允许的地址的数据报到内核日志中。<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.all.mc_forwarding</td><td width="1100">是否进行多播路由。只有内核编译有 CONFIG_MROUTE 并且有路由服务程序在运行该参数才有效。<br>0：禁止<br>1：允许</td></tr><tr><td height="72">net.ipv4.conf.all.medium_id</td><td width="1100">通常, 这个参数用来区分不同媒介. 两个网络设备可以使用不同的值, 使他们只有其中之一接收到广播包. 通常, 这个参数被用来配合 proxy_arp 实现 roxy_arp 的特性即是允许 arp 报文在两个不同的网络介质中转发.<br>0：表示各个网络介质接受他们自己介质上的媒介<br>-1：表示该媒介未知。</td></tr><tr><td height="36">net.ipv4.conf.all.promote_secondaries</td><td width="1100">0：当接口的主 IP 地址被移除时，删除所有次 IP 地址<br>1：当接口的主 IP 地址被移除时，将次 IP 地址提升为主 IP 地址</td></tr><tr><td height="54">net.ipv4.conf.all.proxy_arp</td><td width="1100">打开 arp 代理功能。<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.all.proxy_arp_pvlan</td><td width="1100">回应代理 ARP 的数据包从接收到此代理 ARP 请求的网络接口出去。</td></tr><tr><td height="18">net.ipv4.conf.all.route_localnet</td><td width="1100">&nbsp;</td></tr><tr><td height="36">net.ipv4.conf.all.rp_filter</td><td width="1100">1：通过反向路径回溯进行源地址验证 (在 RFC1812 中定义)。对于单穴主机和 stub 网络路由器推荐使用该选项。<br>0：不通过反向路径回溯进行源地址验证。</td></tr><tr><td height="54">net.ipv4.conf.all.secure_redirects</td><td width="1100">仅仅接收发给默认网关列表中网关的 ICMP 重定向消息<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.all.send_redirects</td><td width="1100">允许发送重定向消息。(路由使用)<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.all.shared_media</td><td width="1100">发送或接收 RFC1620 共享媒体重定向。会覆盖 ip_secure_redirects 的值。<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.all.src_valid_mark</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.conf.all.tag</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.accept_local</td><td width="1100">设置是否允许接收从本机 IP 地址上发送给本机的数据包<br>0：不允许<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.accept_redirects</td><td width="1100">收发接收 ICMP 重定向消息。对于主机来说默认为 True，对于用作路由器时默认值为 False<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.{网络接口}.accept_source_route</td><td width="1100">接收带有 SRR 选项的数据报。主机设为 0，路由设为 1</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.arp_accept</td><td width="1100">默认对不在 ARP 表中的 IP 地址发出的 APR 包的处理方式<br>0：不在 ARP 表中创建对应 IP 地址的表项<br>1：在 ARP 表中创建对应 IP 地址的表项</td></tr><tr><td height="108">net.ipv4.conf.{网络接口}.arp_announce</td><td width="1100">对网络接口上，本地 IP 地址的发出的，ARP 回应，作出相应级别的限制: 确定不同程度的限制, 宣布对来自本地源 IP 地址发出 Arp 请求的接口<br>0： 在任意网络接口（eth0,eth1，lo）上的任何本地地址<br>1：尽量避免不在该网络接口子网段的本地地址做出 arp 回应. 当发起 ARP 请求的源 IP 地址是被设置应该经由路由达到此网络接口的时候很有用. 此时会检查来访 IP 是否为所有接口上的子网段内 ip 之一. 如果改来访 IP 不属于各个网络接口上的子网段内, 那么将采用级别 2 的方式来进行处理.<br>2：对查询目标使用最适当的本地地址. 在此模式下将忽略这个 IP 数据包的源地址并尝试选择与能与该地址通信的本地地址. 首要是选择所有的网络接口的子网中外出访问子网中包含该目标 IP 地址的本地地址. 如果没有合适的地址被发现, 将选择当前的发送网络接口或其他的有可能接受到该 ARP 回应的网络接口来进行发送.</td></tr><tr><td height="72">net.ipv4.conf.{网络接口}.arp_filter</td><td width="1100">0：内核设置每个网络接口各自应答其地址上的 arp 询问。这项看似会错误的设置却经常能非常有效，因为它增加了成功通讯的机会。在 Linux 主机上，每个 IP 地址是网络接口独立的，而非一个复合的接口。只有在一些特殊的设置的时候，比如负载均衡的时候会带来麻烦。<br>1：允许多个网络介质位于同一子网段内，每个网络界面依据是否内核指派路由该数据包经过此接口来确认是否回答 ARP 查询 (这个实现是由来源地址确定路由的时候决定的), 换句话说，允许控制使用某一块网卡（通常是第一块）回应 arp 询问。</td></tr><tr><td height="108">net.ipv4.conf.{网络接口}.arp_ignore</td><td width="1100">定义对目标地址为本地 IP 的 ARP 询问不同的应答模式<br>0：回应任何网络接口上对任何本地 IP 地址的 arp 查询请求<br>1：只回答目标 IP 地址是来访网络接口本地地址的 ARP 查询请求<br>2：只回答目标 IP 地址是来访网络接口本地地址的 ARP 查询请求, 且来访 IP 必须在该网络接口的子网段内<br>3：不回应该网络界面的 arp 请求，而只对设置的唯一和连接地址做出回应<br>8：不回应所有（本地地址）的 arp 查询</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.arp_notify</td><td width="1100">arp 通知链操作<br>0：不做任何操作<br>1：当设备或硬件地址改变时自动产生一个 arp 请求</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.bootp_relay</td><td width="1100">接收源地址为 0.a.b.c，目的地址不是本机的数据包，是为了支持 bootp 服务<br>0：关闭<br>1：开启</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.disable_policy</td><td width="1100">禁止 internet 协议安全性验证<br>0：禁止禁止<br>1：开启禁止</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.disable_xfrm</td><td width="1100">禁止 internet 协议安全性加密<br>0：禁止禁止<br>1：开启禁止</td></tr><tr><td height="18">net.ipv4.conf.{网络接口}.force_igmp_version</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.forwarding</td><td width="1100">在该接口打开转发功能<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.log_martians</td><td width="1100">记录带有不允许的地址的数据报到内核日志中。<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.mc_forwarding</td><td width="1100">是否进行多播路由。只有内核编译有 CONFIG_MROUTE 并且有路由服务程序在运行该参数才有效。<br>0：禁止<br>1：允许</td></tr><tr><td height="72">net.ipv4.conf.{网络接口}.medium_id</td><td width="1100">通常, 这个参数用来区分不同媒介. 两个网络设备可以使用不同的值, 使他们只有其中之一接收到广播包. 通常, 这个参数被用来配合 proxy_arp 实现 roxy_arp 的特性即是允许 arp 报文在两个不同的网络介质中转发.<br>0：表示各个网络介质接受他们自己介质上的媒介<br>-1：表示该媒介未知。</td></tr><tr><td height="36">net.ipv4.conf.{网络接口}.promote_secondaries</td><td width="1100">0：当接口的主 IP 地址被移除时，删除所有次 IP 地址<br>1：当接口的主 IP 地址被移除时，将次 IP 地址提升为主 IP 地址</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.proxy_arp</td><td width="1100">打开 arp 代理功能。<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.{网络接口}.proxy_arp_pvlan</td><td width="1100">回应代理 ARP 的数据包从接收到此代理 ARP 请求的网络接口出去。</td></tr><tr><td height="18">net.ipv4.conf.{网络接口}.route_localnet</td><td width="1100">&nbsp;</td></tr><tr><td height="36">net.ipv4.conf.{网络接口}.rp_filter</td><td width="1100">1：通过反向路径回溯进行源地址验证 (在 RFC1812 中定义)。对于单穴主机和 stub 网络路由器推荐使用该选项。<br>0：不通过反向路径回溯进行源地址验证。</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.secure_redirects</td><td width="1100">仅仅接收发给默认网关列表中网关的 ICMP 重定向消息<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.send_redirects</td><td width="1100">允许发送重定向消息。(路由使用)<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.{网络接口}.shared_media</td><td width="1100">发送或接收 RFC1620 共享媒体重定向。会覆盖 ip_secure_redirects 的值。<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.{网络接口}.src_valid_mark</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.conf.{网络接口}.tag</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.conf.default.accept_local</td><td width="1100">设置是否允许接收从本机 IP 地址上发送给本机的数据包<br>0：不允许<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.default.accept_redirects</td><td width="1100">收发接收 ICMP 重定向消息。对于主机来说默认为 True，对于用作路由器时默认值为 False<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.default.accept_source_route</td><td width="1100">接收带有 SRR 选项的数据报。主机设为 0，路由设为 1</td></tr><tr><td height="54">net.ipv4.conf.default.arp_accept</td><td width="1100">默认对不在 ARP 表中的 IP 地址发出的 APR 包的处理方式<br>0：不在 ARP 表中创建对应 IP 地址的表项<br>1：在 ARP 表中创建对应 IP 地址的表项</td></tr><tr><td height="108">net.ipv4.conf.default.arp_announce</td><td width="1100">对网络接口上，本地 IP 地址的发出的，ARP 回应，作出相应级别的限制: 确定不同程度的限制, 宣布对来自本地源 IP 地址发出 Arp 请求的接口<br>0： 在任意网络接口（eth0,eth1，lo）上的任何本地地址<br>1：尽量避免不在该网络接口子网段的本地地址做出 arp 回应. 当发起 ARP 请求的源 IP 地址是被设置应该经由路由达到此网络接口的时候很有用. 此时会检查来访 IP 是否为所有接口上的子网段内 ip 之一. 如果改来访 IP 不属于各个网络接口上的子网段内, 那么将采用级别 2 的方式来进行处理.<br>2：对查询目标使用最适当的本地地址. 在此模式下将忽略这个 IP 数据包的源地址并尝试选择与能与该地址通信的本地地址. 首要是选择所有的网络接口的子网中外出访问子网中包含该目标 IP 地址的本地地址. 如果没有合适的地址被发现, 将选择当前的发送网络接口或其他的有可能接受到该 ARP 回应的网络接口来进行发送.</td></tr><tr><td height="72">net.ipv4.conf.default.arp_filter</td><td width="1100">0：内核设置每个网络接口各自应答其地址上的 arp 询问。这项看似会错误的设置却经常能非常有效，因为它增加了成功通讯的机会。在 Linux 主机上，每个 IP 地址是网络接口独立的，而非一个复合的接口。只有在一些特殊的设置的时候，比如负载均衡的时候会带来麻烦。<br>1：允许多个网络介质位于同一子网段内，每个网络界面依据是否内核指派路由该数据包经过此接口来确认是否回答 ARP 查询 (这个实现是由来源地址确定路由的时候决定的), 换句话说，允许控制使用某一块网卡（通常是第一块）回应 arp 询问。</td></tr><tr><td height="108">net.ipv4.conf.default.arp_ignore</td><td width="1100">定义对目标地址为本地 IP 的 ARP 询问不同的应答模式<br>0：回应任何网络接口上对任何本地 IP 地址的 arp 查询请求<br>1：只回答目标 IP 地址是来访网络接口本地地址的 ARP 查询请求<br>2：只回答目标 IP 地址是来访网络接口本地地址的 ARP 查询请求, 且来访 IP 必须在该网络接口的子网段内<br>3：不回应该网络界面的 arp 请求，而只对设置的唯一和连接地址做出回应<br>8：不回应所有（本地地址）的 arp 查询</td></tr><tr><td height="54">net.ipv4.conf.default.arp_notify</td><td width="1100">arp 通知链操作<br>0：不做任何操作<br>1：当设备或硬件地址改变时自动产生一个 arp 请求</td></tr><tr><td height="54">net.ipv4.conf.default.bootp_relay</td><td width="1100">接收源地址为 0.a.b.c，目的地址不是本机的数据包，是为了支持 bootp 服务<br>0：关闭<br>1：开启</td></tr><tr><td height="54">net.ipv4.conf.default.disable_policy</td><td width="1100">禁止 internet 协议安全性验证<br>0：禁止禁止<br>1：开启禁止</td></tr><tr><td height="54">net.ipv4.conf.default.disable_xfrm</td><td width="1100">禁止 internet 协议安全性加密<br>0：禁止禁止<br>1：开启禁止</td></tr><tr><td height="18">net.ipv4.conf.default.force_igmp_version</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.conf.default.forwarding</td><td width="1100">在该接口打开转发功能<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.default.log_martians</td><td width="1100">记录带有不允许的地址的数据报到内核日志中。<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.default.mc_forwarding</td><td width="1100">是否进行多播路由。只有内核编译有 CONFIG_MROUTE 并且有路由服务程序在运行该参数才有效。<br>0：禁止<br>1：允许</td></tr><tr><td height="72">net.ipv4.conf.default.medium_id</td><td width="1100">通常, 这个参数用来区分不同媒介. 两个网络设备可以使用不同的值, 使他们只有其中之一接收到广播包. 通常, 这个参数被用来配合 proxy_arp 实现 roxy_arp 的特性即是允许 arp 报文在两个不同的网络介质中转发.<br>0：表示各个网络介质接受他们自己介质上的媒介<br>-1：表示该媒介未知。</td></tr><tr><td height="36">net.ipv4.conf.default.promote_secondaries</td><td width="1100">0：当接口的主 IP 地址被移除时，删除所有次 IP 地址<br>1：当接口的主 IP 地址被移除时，将次 IP 地址提升为主 IP 地址</td></tr><tr><td height="54">net.ipv4.conf.default.proxy_arp</td><td width="1100">打开 arp 代理功能。<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.default.proxy_arp_pvlan</td><td width="1100">回应代理 ARP 的数据包从接收到此代理 ARP 请求的网络接口出去。</td></tr><tr><td height="18">net.ipv4.conf.default.route_localnet</td><td width="1100">&nbsp;</td></tr><tr><td height="36">net.ipv4.conf.default.rp_filter</td><td width="1100">1：通过反向路径回溯进行源地址验证 (在 RFC1812 中定义)。对于单穴主机和 stub 网络路由器推荐使用该选项。<br>0：不通过反向路径回溯进行源地址验证。</td></tr><tr><td height="54">net.ipv4.conf.default.secure_redirects</td><td width="1100">仅仅接收发给默认网关列表中网关的 ICMP 重定向消息<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.default.send_redirects</td><td width="1100">允许发送重定向消息。(路由使用)<br>0：禁止<br>1：允许</td></tr><tr><td height="54">net.ipv4.conf.default.shared_media</td><td width="1100">发送或接收 RFC1620 共享媒体重定向。会覆盖 ip_secure_redirects 的值。<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.conf.default.src_valid_mark</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.conf.default.tag</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.icmp_echo_ignore_all</td><td width="1100">忽略所有接收到的 icmp echo 请求的包 (会导致机器无法 ping 通)<br>0：不忽略<br>1：忽略</td></tr><tr><td height="54">net.ipv4.icmp_echo_ignore_broadcasts</td><td width="1100">忽略所有接收到的 icmp echo 请求的广播<br>0：不忽略<br>1：忽略</td></tr><tr><td height="36">net.ipv4.icmp_errors_use_inbound_ifaddr</td><td width="1100">当前为 ICMP 错误消息选择源地址的方式，是使用存在的接口地址<br>1：表示内核通过这个选项允许使用接收到造成这一错误的报文的接口的地址</td></tr><tr><td height="54">net.ipv4.icmp_ignore_bogus_error_responses</td><td width="1100">某些路由器违背 RFC1122 标准，其对广播帧发送伪造的响应来应答。这种违背行为通常会被以警告的方式记录在系统日志中。<br>0：记录到系统日志中<br>1：忽略</td></tr><tr><td height="54">net.ipv4.icmp_ratelimit</td><td width="1100">限制发向特定目标的匹配 icmp_ratemask 的 ICMP 数据报的最大速率。配合 icmp_ratemask 使用。<br>0：没有任何限制<br>&gt;0：表示指定时间内中允许发送的个数。(以 jiffies 为单位)</td></tr><tr><td height="306">net.ipv4.icmp_ratemask</td><td width="1100">在这里匹配的 ICMP 被 icmp_ratelimit 参数限制速率.<br>匹配的标志位: ＩＨＧＦＥＤＣＢＡ９８７６５４３２１０<br>默认的掩码值: ００００００１１００００００１１０００ (6168)<br>0 Echo Reply<br>3 Destination Unreachable *<br>4 Source Quench *<br>5 Redirect<br>8 Echo Request<br>B Time Exceeded *<br>C Parameter Problem *<br>D Timestamp Request<br>E Timestamp Reply<br>F Info Request<br>G Info Reply<br>H Address Mask Request<br>I Address Mask Reply<br>* 号的被默认限速</td></tr><tr><td height="18">net.ipv4.igmp_max_memberships</td><td width="1100">限制加入一个多播组的最大成员数.</td></tr><tr><td height="18">net.ipv4.igmp_max_msf</td><td width="1100">限制多播源地址过滤数量.</td></tr><tr><td height="18">net.ipv4.igmp_qrv</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.inet_peer_maxttl</td><td width="1100">条目的最大存活期。在此期限到达之后，如果缓冲池没有耗尽压力的话 (例如：缓冲池中的条目数目非常少)，不使用的条目将会超时。该值以 jiffies 为单位测量。</td></tr><tr><td height="36">net.ipv4.inet_peer_minttl</td><td width="1100">条目的最低存活期。在重组端必须要有足够的碎片 (fragment) 存活期。这个最低存活期必须保证缓冲池容积是否少于 inet_peer_threshold。该值以 jiffies 为单位测量。</td></tr><tr><td height="18">net.ipv4.inet_peer_threshold</td><td width="1100">INET 对端存储器某个合适值，当超过该阀值条目将被丢弃。该阀值同样决定生存时间以及废物收集通过的时间间隔。条目越多，存活期越低，GC 间隔越短。</td></tr><tr><td height="18">net.ipv4.ip_default_ttl</td><td width="1100">该文件表示一个数据报的生存周期（Time To Live），即最多经过多少路由器。</td></tr><tr><td height="54">net.ipv4.ip_dynaddr</td><td width="1100">拨号上网大部分都是使用动态 IP 地址，我们不知道远程拨号服务器的 IP 地址是多少，也不可能知道它会给电脑分配什么 IP 地址<br>0：使用静态 IP<br>1：使用动态 IP 地址</td></tr><tr><td height="18">net.ipv4.ip_early_demux</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.ip_forward</td><td width="1100">是否打开 ipv4 的 IP 转发。<br>0：禁止<br>1：打开</td></tr><tr><td height="18">net.ipv4.ip_forward_use_pmtu</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.ipfrag_high_thresh</td><td width="1100">表示用于重组 IP 分段的内存分配最高值，一旦达到最高内存分配值，其它分段将被丢弃，直到达到最低内存分配值。</td></tr><tr><td height="18">net.ipv4.ipfrag_low_thresh</td><td width="1100">表示用于重组 IP 分段的内存分配最低值</td></tr><tr><td height="36">net.ipv4.ipfrag_max_dist</td><td width="1100">相同的源地址 ip 碎片数据报的最大数量. 这个变量表示在 ip 碎片被添加到队列前要作额外的检查. 如果超过定义的数量的 ip 碎片从一个相同源地址到达，那么假定这个队列的 ip 碎片有丢失，已经存在的 ip 碎片队列会被丢弃，如果为 0 关闭检查</td></tr><tr><td height="18">net.ipv4.ipfrag_secret_interval</td><td width="1100">hash 表中 ip 碎片队列的重建延迟.(单位 秒)</td></tr><tr><td height="18">net.ipv4.ipfrag_time</td><td width="1100">表示一个 IP 分段在内存中保留多少秒</td></tr><tr><td height="18">net.ipv4.ip_local_port_range</td><td width="1100">本地发起连接时使用的端口范围，tcp 初始化时会修改此值</td></tr><tr><td height="18">net.ipv4.ip_local_reserved_ports</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.ip_nonlocal_bind</td><td width="1100">允许进程绑定到非本地地址<br>0：禁止<br>1：允许</td></tr><tr><td height="18">net.ipv4.ip_no_pmtu_disc</td><td width="1100">该文件表示在全局范围内关闭路径 MTU 探测功能。</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.anycast_delay</td><td width="1100">对相邻请求信息的回复的最大延迟时间 (单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.app_solicit</td><td width="1100">在使用多播探测前，通过 netlink 发送到用户空间 arp 守护程序的最大探测数</td></tr><tr><td height="36">net.ipv4.neigh.{网络接口}.base_reachable_time</td><td width="1100">一旦发现相邻记录，至少在一段介于 base_reachable_time/2 和 3*base_reachable_time/2 之间的随机时间内，该记录是有效的.<br>如果收到上层协议的肯定反馈， 那么记录的有效期将延长.(单位 秒)</td></tr><tr><td height="36">net.ipv4.neigh.{网络接口}.base_reachable_time_ms</td><td width="1100">一旦发现相邻记录，至少在一段介于 base_reachable_time/2 和 3*base_reachable_time/2 之间的随机时间内，该记录是有效的.<br>如果收到上层协议的肯定反馈， 那么记录的有效期将延长.(单位 毫秒)</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.delay_first_probe_time</td><td width="1100">发现某个相邻层记录无效后，发出第一个探测要等待的时间。(单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.gc_stale_time</td><td width="1100">决定检查一次相邻层记录的有效性的周期. 当相邻层记录失效时，将在给它发送数据前，再解析一次.(单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.locktime</td><td width="1100">防止相邻记录被过度频繁刷新，引起抖动，只有距邻居上次刷新时间超过这时才允许被再次刷新.(单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.mcast_solicit</td><td width="1100">在把记录标记为不可达之前， 用多播 / 广播方式解析地址的最大次数.</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.proxy_delay</td><td width="1100">当接收到有一个 arp 请求时，在回应前可以延迟的时间，这个请求是要得到一个已知代理 arp 项的地址.(单位 百毫秒)</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.proxy_qlen</td><td width="1100">能放入代理 ARP 地址队列的数据包最大数目.</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.retrans_time</td><td width="1100">重发一个 arp 请求前的等待的秒数</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.retrans_time_ms</td><td width="1100">重发一个 arp 请求前的等待的毫秒数</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.ucast_solicit</td><td width="1100">arp 请求最多发送次数</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.unres_qlen</td><td width="1100">最大挂起 arp 请求的数量，这些请求都正在被解析中.</td></tr><tr><td height="18">net.ipv4.neigh.{网络接口}.unres_qlen_bytes</td><td width="1100">最大处理 arp 包的字节数</td></tr><tr><td height="18">net.ipv4.neigh.default.anycast_delay</td><td width="1100">对相邻请求信息的回复的最大延迟时间 (单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.default.app_solicit</td><td width="1100">在使用多播探测前，通过 netlink 发送到用户空间 arp 守护程序的最大探测数</td></tr><tr><td height="36">net.ipv4.neigh.default.base_reachable_time</td><td width="1100">一旦发现相邻记录，至少在一段介于 base_reachable_time/2 和 3*base_reachable_time/2 之间的随机时间内，该记录是有效的.<br>如果收到上层协议的肯定反馈， 那么记录的有效期将延长.(单位 秒)</td></tr><tr><td height="36">net.ipv4.neigh.default.base_reachable_time_ms</td><td width="1100">一旦发现相邻记录，至少在一段介于 base_reachable_time/2 和 3*base_reachable_time/2 之间的随机时间内，该记录是有效的.<br>如果收到上层协议的肯定反馈， 那么记录的有效期将延长.(单位 毫秒)</td></tr><tr><td height="18">net.ipv4.neigh.default.delay_first_probe_time</td><td width="1100">发现某个相邻层记录无效后，发出第一个探测要等待的时间。(单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.default.gc_interval</td><td width="1100">垃圾收集器收集相邻层记录和无用记录的运行周期 (单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.default.gc_stale_time</td><td width="1100">决定检查一次相邻层记录的有效性的周期. 当相邻层记录失效时，将在给它发送数据前，再解析一次.(单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.default.gc_thresh1</td><td width="1100">存在于 ARP 高速缓存中的最少个数，如果少于这个数，垃圾收集器将不会运行</td></tr><tr><td height="18">net.ipv4.neigh.default.gc_thresh2</td><td width="1100">保存在 ARP 高速缓存中的最多的记录软限制. 垃圾收集器在开始收集前，允许记录数超过这个数字，在创建新表项时如果发现 5 秒没有刷新过，那么进行强制回收</td></tr><tr><td height="18">net.ipv4.neigh.default.gc_thresh3</td><td width="1100">保存在 ARP 高速缓存中的最多记录的硬限制， 一旦高速缓存中的数目高于此， 垃圾收集器将马上运行</td></tr><tr><td height="18">net.ipv4.neigh.default.locktime</td><td width="1100">防止相邻记录被过度频繁刷新，引起抖动，只有距邻居上次刷新时间超过这时才允许被再次刷新.(单位 秒)</td></tr><tr><td height="18">net.ipv4.neigh.default.mcast_solicit</td><td width="1100">在把记录标记为不可达之前， 用多播 / 广播方式解析地址的最大次数.</td></tr><tr><td height="18">net.ipv4.neigh.default.proxy_delay</td><td width="1100">当接收到有一个 arp 请求时，在回应前可以延迟的时间，这个请求是要得到一个已知代理 arp 项的地址.(单位 百毫秒)</td></tr><tr><td height="18">net.ipv4.neigh.default.proxy_qlen</td><td width="1100">能放入代理 ARP 地址队列的数据包最大数目.</td></tr><tr><td height="18">net.ipv4.neigh.default.retrans_time</td><td width="1100">重发一个 arp 请求前的等待的秒数</td></tr><tr><td height="18">net.ipv4.neigh.default.retrans_time_ms</td><td width="1100">重发一个 arp 请求前的等待的毫秒数</td></tr><tr><td height="18">net.ipv4.neigh.default.ucast_solicit</td><td width="1100">arp 请求最多发送次数</td></tr><tr><td height="18">net.ipv4.neigh.default.unres_qlen</td><td width="1100">最大挂起 arp 请求的数量，这些请求都正在被解析中.</td></tr><tr><td height="18">net.ipv4.neigh.default.unres_qlen_bytes</td><td width="1100">最大处理 arp 包的字节数</td></tr><tr><td height="18">net.ipv4.ping_group_range</td><td width="1100">&nbsp;</td></tr><tr><td height="36">net.ipv4.route.error_burst</td><td width="1100">这个参数和 error_cast 一起用于限制有多少个 icmp 不可达消息被发送. 当数据包不能到达下一跳时会发送 icmp 不可达数据包.<br>当一些主机忽略我们的 icmp 重定向消息时也会打印一些错误信息到 dmesg. 这个选项也控制打印的次数.(单位 秒)</td></tr><tr><td height="54">net.ipv4.route.error_cost</td><td width="1100">这个参数和 error_burst 一起用于限制有多少个 icmp 不可达消息被发送. 当数据包不能到达下一跳时会发送 icmp 不可达数据包.<br>当一些主机忽略我们的 icmp 重定向消息时也会打印一些错误信息到 dmesg. 这个选项也控制打印的次数.<br>error_cost 值越大，那么 icmp 不可达和写错误信息的频率就越低.(单位 秒)</td></tr><tr><td height="18">net.ipv4.route.flush</td><td width="1100">写这个文件就会刷新路由高速缓冲.</td></tr><tr><td height="36">net.ipv4.route.gc_elasticity</td><td width="1100">用来控制路由缓存垃圾回收机制的频率和行为. 当路由表一个 hash 项的长度超过此值时，会进行缓存缩减, 当路由缓存项长度超过<br>ip_rt_gc_elasticity &lt;&lt;rt_hash_log(表示路由高速缓存 hash table 的容量以 2 为对数所得的值) 时会进行强烈的回收.</td></tr><tr><td height="18">net.ipv4.route.gc_interval</td><td width="1100">此参数定义了路由表垃圾回收的间隔 (秒)</td></tr><tr><td height="18">net.ipv4.route.gc_min_interval</td><td width="1100">已不再使用，并被 gc_min_interval_ms 取代</td></tr><tr><td height="18">net.ipv4.route.gc_min_interval_ms</td><td width="1100">此参数定义了路由表垃圾回收的最小间隔 (ms)</td></tr><tr><td height="18">net.ipv4.route.gc_thresh</td><td width="1100">路由 hash table 的大小，当 cache 中的路由条数超过此值时，开始垃圾回收.</td></tr><tr><td height="18">net.ipv4.route.gc_timeout</td><td width="1100">设置一个路由表项的过期时长 (秒).</td></tr><tr><td height="18">net.ipv4.route.max_size</td><td width="1100">路由高速缓存的最大项数，超过会进行清除旧项操作.</td></tr><tr><td height="18">net.ipv4.route.min_adv_mss</td><td width="1100">该文件表示最小的 MSS（Maximum Segment Size）大小，取决于第一跳的路由器 MTU。(以字节为单位)</td></tr><tr><td height="18">net.ipv4.route.min_pmtu</td><td width="1100">该文件表示最小路径 MTU 的大小。</td></tr><tr><td height="18">net.ipv4.route.mtu_expires</td><td width="1100">该文件表示 PMTU 信息缓存多长时间（秒）。</td></tr><tr><td height="18">net.ipv4.route.redirect_load</td><td width="1100">决定是否要向特定主机发送更多的 ICMP 重定向的时间因子. 一旦达到 load 时间或 number 个数就不再发送.</td></tr><tr><td height="18">net.ipv4.route.redirect_number</td><td width="1100">决定是否要向特定主机发送更多的 ICMP 重定向的数量因子. 一旦达到 load 时间或 number 个数就不再发送.</td></tr><tr><td height="18">net.ipv4.route.redirect_silence</td><td width="1100">重定向的超时. 经过这么长时间后, 重定向会重发, 而不管是否已经因为超过 load 或者 number 限制而停止.</td></tr><tr><td height="54">net.ipv4.tcp_abort_on_overflow</td><td width="1100">守护进程太忙而不能接受新的连接，就向对方发送 reset 消息<br>0：关闭<br>1：开启</td></tr><tr><td height="18">net.ipv4.tcp_adv_win_scale</td><td width="1100">计算缓冲开销 bytes/2^tcp_adv_win_scale(如果 tcp_adv_win_scale&gt; 0) 或者 bytes-bytes/2^(-tcp_adv_win_scale)(如果 tcp_adv_win_scale &lt;= 0）。</td></tr><tr><td height="18">net.ipv4.tcp_allowed_congestion_control</td><td width="1100">列出了 tcp 目前允许使用的拥塞控制算法，只能在下面可用的算法中选择.</td></tr><tr><td height="18">net.ipv4.tcp_app_win</td><td width="1100">保留 max(window/2^tcp_app_win, mss) 数量的窗口用于应用缓冲。当为 0 时表示不需要缓冲。</td></tr><tr><td height="18">net.ipv4.tcp_available_congestion_control</td><td width="1100">列出了 tcp 目前可以使用的拥塞控制算法.</td></tr><tr><td height="18">net.ipv4.tcp_base_mss</td><td width="1100">tcp 探察路径上 mtu 的最低边界限制, mss+TCP 头部 + TCP 选项 + IP 头＋IP 选项.</td></tr><tr><td height="18">net.ipv4.tcp_challenge_ack_limit</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.tcp_congestion_control</td><td width="1100">当前正在使用的拥塞控制算法.</td></tr><tr><td height="54">net.ipv4.tcp_dsack</td><td width="1100">表示是否允许 TCP 发送 “两个完全相同” 的 SACK。<br>0：禁止<br>1：启用</td></tr><tr><td height="18">net.ipv4.tcp_early_retrans</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.tcp_ecn</td><td width="1100">表示是否打开 TCP 的直接拥塞通告功能。<br>0：禁止<br>1：启用</td></tr><tr><td height="54">net.ipv4.tcp_fack</td><td width="1100">表示是否打开 FACK 拥塞避免和快速重传功能。<br>0：禁止<br>1：打开</td></tr><tr><td height="18">net.ipv4.tcp_fastopen</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.tcp_fastopen_key</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.tcp_fin_timeout</td><td width="1100">本端断开的 socket 连接，TCP 保持在 FIN-WAIT-2 状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。过去在 2.2 版本的内核中是 180 秒。您可以设置该值，但需要注意，如果您的机器为负载很重的 web 服务器，您可能要冒内存被大量无效数据报填满的风险，FIN-WAIT-2 sockets 的危险性低于 FIN-WAIT-1，因为它们最多只吃 1.5K 的内存，但是它们存在时间更长。</td></tr><tr><td height="18">net.ipv4.tcp_frto</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.tcp_keepalive_intvl</td><td width="1100">表示发送 TCP 探测的频率，乘以 tcp_keepalive_probes 表示断开没有相应的 TCP 连接的时间。</td></tr><tr><td height="18">net.ipv4.tcp_keepalive_probes</td><td width="1100">该文件表示丢弃 TCP 连接前，进行最大 TCP 保持连接侦测的次数。保持连接仅在 SO_KEEPALIVE 套接字选项被打开时才被发送。</td></tr><tr><td height="18">net.ipv4.tcp_keepalive_time</td><td width="1100">表示从最后一个包结束后多少秒内没有活动，才发送 keepalive 包保持连接，默认 7200s，理想可设为 1800s，即如果非正常断开，1800s 后可通过 keepalive 知道。</td></tr><tr><td height="18">net.ipv4.tcp_limit_output_bytes</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.tcp_low_latency</td><td width="1100">允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用。(但在构建 Beowulf 集群的时候, 打开它很有帮助)<br>0：关闭<br>1：开启</td></tr><tr><td height="36">net.ipv4.tcp_max_orphans</td><td width="1100">系统所能处理不属于任何进程的 TCP sockets 最大数量。假如超过这个数量，那么不属于任何进程的连接会被立即 reset，并同时显示警告信息。之所以要设定这个限制，纯粹为了抵御那些简单的 DoS 攻击，千万不要依赖这个或是人为的降低这个限制。</td></tr><tr><td height="18">net.ipv4.tcp_max_ssthresh</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.tcp_max_syn_backlog</td><td width="1100">对于那些依然还未获得客户端确认的连接请求，需要保存在队列中最大数目。默认值是 1024，可提高到 2048。</td></tr><tr><td height="18">net.ipv4.tcp_max_tw_buckets</td><td width="1100">系统在同时所处理的最大 timewait sockets 数目。如果超过此数的话，time-wait socket 会被立即砍除并且显示警告信息。</td></tr><tr><td height="72">net.ipv4.tcp_mem</td><td width="1100">该文件保存了三个值，分别是<br>low：当 TCP 使用了低于该值的内存页面数时，TCP 不会考虑释放内存。<br>presure：当 TCP 使用了超过该值的内存页面数量时，TCP 试图稳定其内存使用，进入 pressure 模式，当内存消耗低于 low 值时则退出 pressure 状态。<br>high：允许所有 tcp sockets 用于排队缓冲数据报的页面量。</td></tr><tr><td height="18">net.ipv4.tcp_min_tso_segs</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.tcp_moderate_rcvbuf</td><td width="1100">接收数据时是否调整接收缓存<br>0：不调整<br>1：调整</td></tr><tr><td height="54">net.ipv4.tcp_mtu_probing</td><td width="1100">是否开启 tcp 层路径 mtu 发现，自动调整 tcp 窗口等信<br>0：关闭<br>1：开启</td></tr><tr><td height="72">net.ipv4.tcp_no_metrics_save</td><td width="1100">如果开启，tcp 会在连接关闭时也就是 LAST_ACK 状态保存各种连接信息到路由缓存中，新建立的连接可以使用这些条件来初始化.。通常这会增加总体的系统性能，但是有些时候也会引起性能下降.<br>0：关闭<br>1：开启</td></tr><tr><td height="18">net.ipv4.tcp_orphan_retries</td><td width="1100">针对孤立的 socket(也就是已经从进程上下文中删除了，可是还有一些清理工作没有完成). 在丢弃 TCP 连接之前重试的最大的次数</td></tr><tr><td height="18">net.ipv4.tcp_reordering</td><td width="1100">TCP 流中重排序的数据报最大数量。</td></tr><tr><td height="54">net.ipv4.tcp_retrans_collapse</td><td width="1100">对于某些有 bug 的打印机提供针对其 bug 的兼容性。<br>0：不启用<br>1：启用</td></tr><tr><td height="18">net.ipv4.tcp_retries1</td><td width="1100">该文件表示放弃回应一个 TCP 连接请求前进行重传的次数。</td></tr><tr><td height="18">net.ipv4.tcp_retries2</td><td width="1100">该文件表示放弃在已经建立通讯状态下的一个 TCP 数据包前进行重传的次数。</td></tr><tr><td height="54">net.ipv4.tcp_rfc1337</td><td width="1100">这个开关可以启动对于在 RFC1337 中描述的 "tcp 的 time-wait 暗杀危机" 问题的修复。启用后，内核将丢弃那些发往 time-wait 状态 TCP 套接字的 RST 包.<br>0：关闭<br>1：开启</td></tr><tr><td height="108">net.ipv4.tcp_rmem</td><td width="1100">此文件中保存有三个值，分别是<br>Min：为 TCP socket 预留用于接收缓冲的内存最小值。每个 tcp socket 都可以在建立后使用它。即使在内存出现紧张情况下 tcp socket 都至少会有这么多数量的内存用于接收缓冲<br>Default：为 TCP socket 预留用于接收缓冲的内存数量，默认情况下该值会影响其它协议使用的 net.core.rmem_default 值，一般要低于 net.core.rmem_default 的值。该值决定了在 tcp_adv_win_scale、tcp_app_win 和 tcp_app_win=0 默认值情况下，TCP 窗口大小为 65535。<br>Max：用于 TCP socket 接收缓冲的内存最大值。该值不会影响 net.core.rmem_max，"静态" 选择参数 SO_SNDBUF 则不受该值影响。</td></tr><tr><td height="72">net.ipv4.tcp_sack</td><td width="1100">表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）；（对于广域网通信来说）这个选项应该启用，但是这会增加对 CPU 的占用。<br>0：不启用<br>1：启用</td></tr><tr><td height="54">net.ipv4.tcp_slow_start_after_idle</td><td width="1100">如果设置满足 RFC2861 定义的行为，在从新开始计算拥塞窗口前延迟一些时间，这延迟的时间长度由当前 rto 决定.<br>0：关闭<br>1：开启</td></tr><tr><td height="54">net.ipv4.tcp_stdurg</td><td width="1100">使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD 解释，因此如果您在 Linux 打开它，或会导致不能和它们正确沟通。<br>0：关闭<br>1：打开</td></tr><tr><td height="36">net.ipv4.tcp_synack_retries</td><td width="1100">对于远端的连接请求 SYN，内核会发送 SYN ＋ ACK 数据报，以确认收到上一个 SYN 连接请求包。<br>这是所谓的三次握手. 这里决定内核在放弃连接之前所送出的 SYN+ACK 数目.</td></tr><tr><td height="72">net.ipv4.tcp_syncookies</td><td width="1100">表示是否打开 TCP 同步标签 (syncookie)，内核必须打开了 CONFIG_SYN_COOKIES 项进行编译。同步标签(syncookie) 可以防止一个套接字在有过多试图连接到达时引起过载。<br>0：关闭<br>1：打开</td></tr><tr><td height="18">net.ipv4.tcp_syn_retries</td><td width="1100">表示本机向外发起 TCP SYN 连接超时重传的次数，不应该高于 255；该值仅仅针对外出的连接，对于进来的连接由 tcp_retries1 控制。</td></tr><tr><td height="18">net.ipv4.tcp_thin_dupack</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.tcp_thin_linear_timeouts</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv4.tcp_timestamps</td><td width="1100">表示是否启用以一种比超时重发更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。<br>0：不启用<br>1：启用</td></tr><tr><td height="54">net.ipv4.tcp_tso_win_divisor</td><td width="1100">控制根据拥塞窗口的百分比，是否来发送相应的延迟 tso frame<br>0：关闭<br>&gt;0：值越大表示 tso frame 延迟发送可能越小.</td></tr><tr><td height="18">net.ipv4.tcp_tw_recycle</td><td width="1100">打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求，请不要随意修改这个值。</td></tr><tr><td height="54">net.ipv4.tcp_tw_reuse</td><td width="1100">表示是否允许重新应用处于 TIME-WAIT 状态的 socket 用于新的 TCP 连接。<br>0：关闭<br>1：打开</td></tr><tr><td height="54">net.ipv4.tcp_window_scaling</td><td width="1100">表示设置 tcp/ip 会话的滑动窗口大小是否可变。<br>0：不可变<br>1：可变</td></tr><tr><td height="90">net.ipv4.tcp_wmem</td><td width="1100">此文件中保存有三个值，分别是<br>Min：为 TCP socket 预留用于发送缓冲的内存最小值。每个 tcp socket 都可以在建立后使用它。<br>Default：为 TCP socket 预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的 net.core.wmem_default 值，一般要低于 net.core.wmem_default 的值。<br>Max：用于 TCP socket 发送缓冲的内存最大值。该值不会影响 net.core.wmem_max，"静态" 选择参数 SO_SNDBUF 则不受该值影响。</td></tr><tr><td height="36">net.ipv4.tcp_workaround_signed_windows</td><td width="1100">0：假定远程连接端正常发送了窗口收缩选项，即使对端没有发送.<br>1：假定远程连接端有错误, 没有发送相关的窗口缩放选项</td></tr><tr><td height="72">net.ipv4.udp_mem</td><td width="1100">该文件保存了三个值，分别是<br>low：当 UDP 使用了低于该值的内存页面数时，UDP 不会考虑释放内存。<br>presure：当 UDP 使用了超过该值的内存页面数量时，UDP 试图稳定其内存使用，进入 pressure 模式，当内存消耗低于 low 值时则退出 pressure 状态。<br>high：允许所有 UDP sockets 用于排队缓冲数据报的页面量。</td></tr><tr><td height="18">net.ipv4.udp_rmem_min</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.udp_wmem_min</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv4.xfrm4_gc_thresh</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv6.bindv6only</td><td width="1100">默认监听 ipv6 端口 (不管监听与否，都与是否关闭 ipv4 监听无关)<br>0：不监听<br>1：监听</td></tr><tr><td height="54">net.ipv6.conf.all.accept_dad</td><td width="1100">0：取消 DAD 功能<br>1：启用 DAD 功能，但 link-local 地址冲突时，不关闭 ipv6 功能<br>2：启用 DAD 功能，但 link-local 地址冲突时，关闭 ipv6 功能</td></tr><tr><td height="72">net.ipv6.conf.all.accept_ra</td><td width="1100">接受 IPv6 路由通告. 并且根据得到的信息自动设定.<br>0：不接受路由通告<br>1：当 forwarding 禁止时接受路由通告<br>2：任何情况下都接受路由通告</td></tr><tr><td height="54">net.ipv6.conf.all.accept_ra_defrtr</td><td width="1100">是否接受 ipv6 路由器发出的默认路由设置<br>0：不接受<br>1：接受</td></tr><tr><td height="18">net.ipv6.conf.all.accept_ra_pinfo</td><td width="1100">当 accept_ra 开启时此选项会自动开启，关闭时则会关闭</td></tr><tr><td height="18">net.ipv6.conf.all.accept_ra_rt_info_max_plen</td><td width="1100">在路由通告中路由信息前缀的最大长度。当</td></tr><tr><td height="18">net.ipv6.conf.all.accept_ra_rtr_pref</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv6.conf.all.accept_redirects</td><td width="1100">是否接受 ICMPv6 重定向包<br>0：拒绝接受 ICMPv6，当 forwarding=1 时，此值会自动设置为 0<br>1：启动接受 ICMPv6，当 forwarding=0 时，此值会自动设置为 1</td></tr><tr><td height="18">net.ipv6.conf.all.accept_source_route</td><td width="1100">接收带有 SRR 选项的数据报。主机设为 0，路由设为 1</td></tr><tr><td height="18">net.ipv6.conf.all.autoconf</td><td width="1100">设定本地连结地址使用 L2 硬件地址. 它依据界面的 L2-MAC address 自动产生一个地址如:"fe80::201:23ff:fe45:6789"</td></tr><tr><td height="18">net.ipv6.conf.all.dad_transmits</td><td width="1100">接口增加 ipv6 地址时，发送几次 DAD 包</td></tr><tr><td height="54">net.ipv6.conf.all.disable_ipv6</td><td width="1100">是否禁用 ipv6<br>0：不禁用<br>1：禁用</td></tr><tr><td height="18">net.ipv6.conf.all.force_mld_version</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.all.force_tllao</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.ipv6.conf.all.forwarding</td><td width="1100">所有网络接口开启 ipv6 转发<br>0：关闭<br>1：开启</td></tr><tr><td height="18">net.ipv6.conf.all.hop_limit</td><td width="1100">缺省 hop 限制</td></tr><tr><td height="54">net.ipv6.conf.all.max_addresses</td><td width="1100">所有网络接口自动配置 IP 地址的数量最大值<br>0：不限制<br>&gt;0：最大值</td></tr><tr><td height="18">net.ipv6.conf.all.max_desync_factor</td><td width="1100">DESYNC_FACTOR 的最大值，DESYNC_FACTOR 是一个随机数，用于防止客户机在同一时间生成新的地址</td></tr><tr><td height="54">net.ipv6.conf.all.mc_forwarding</td><td width="1100">是否使用多路广播进行路由选择，需要内核编译时开启了 CONFIG_MROUTE 选项并且开启了多路广播路由选择的后台 daemon<br>0：关闭<br>1：开启</td></tr><tr><td height="18">net.ipv6.conf.all.mldv1_unsolicited_report_interval</td><td width="1100">每次发送 MLDv1 的主动报告的时间间隔 (ms)</td></tr><tr><td height="18">net.ipv6.conf.all.mldv2_unsolicited_report_interval</td><td width="1100">每次发送 MLDv2 的主动报告的时间间隔 (ms)</td></tr><tr><td height="18">net.ipv6.conf.all.mtu</td><td width="1100">ipv6 的最大传输单元</td></tr><tr><td height="54">net.ipv6.conf.all.ndisc_notify</td><td width="1100">如何向邻居设备通知地址和设备的改变<br>0：不通知<br>1：主动向邻居发送广播报告硬件地址或者设备发生了改变</td></tr><tr><td height="54">net.ipv6.conf.all.optimistic_dad</td><td width="1100">是否启用 optimistic DAD(乐观地进行重复地址检查)<br>0：关闭<br>1：开启</td></tr><tr><td height="54">net.ipv6.conf.all.proxy_ndp</td><td width="1100">此功能类似于 ipv4 的 nat，可将内网的包转发到外网，外网不能主动发给内网。<br>0：关闭<br>1：开启</td></tr><tr><td height="18">net.ipv6.conf.all.regen_max_retry</td><td width="1100">尝试生成临时地址的次数</td></tr><tr><td height="18">net.ipv6.conf.all.router_probe_interval</td><td width="1100">路由器探测间隔 (秒)</td></tr><tr><td height="18">net.ipv6.conf.all.router_solicitation_delay</td><td width="1100">在发送路由请求之前的等待时间 (秒).</td></tr><tr><td height="18">net.ipv6.conf.all.router_solicitation_interval</td><td width="1100">在每个路由请求之间的等待时间 (秒).</td></tr><tr><td height="18">net.ipv6.conf.all.router_solicitations</td><td width="1100">假定没有路由的情况下发送的请求个数</td></tr><tr><td height="18">net.ipv6.conf.all.temp_prefered_lft</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.all.temp_valid_lft</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.all.use_tempaddr</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.accept_dad</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.accept_ra</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.accept_ra_defrtr</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.accept_ra_pinfo</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.accept_ra_rt_info_max_plen</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.accept_ra_rtr_pref</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.accept_redirects</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.accept_source_route</td><td width="1100">接收带有 SRR 选项的数据报。主机设为 0，路由设为 1</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.autoconf</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.dad_transmits</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.disable_ipv6</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.force_mld_version</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.force_tllao</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.forwarding</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.hop_limit</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.max_addresses</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.max_desync_factor</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.mc_forwarding</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.mldv1_unsolicited_report_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.mldv2_unsolicited_report_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.mtu</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.ndisc_notify</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.optimistic_dad</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.proxy_ndp</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.regen_max_retry</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.router_probe_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.router_solicitation_delay</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.router_solicitation_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.router_solicitations</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.temp_prefered_lft</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.temp_valid_lft</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.{网络接口}.use_tempaddr</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.accept_dad</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.accept_ra</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.accept_ra_defrtr</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.accept_ra_pinfo</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.accept_ra_rt_info_max_plen</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.accept_ra_rtr_pref</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.accept_redirects</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.accept_source_route</td><td width="1100">接收带有 SRR 选项的数据报。主机设为 0，路由设为 1</td></tr><tr><td height="18">net.ipv6.conf.default.autoconf</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.dad_transmits</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.disable_ipv6</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.force_mld_version</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.force_tllao</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.forwarding</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.hop_limit</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.max_addresses</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.max_desync_factor</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.mc_forwarding</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.mldv1_unsolicited_report_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.mldv2_unsolicited_report_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.mtu</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.ndisc_notify</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.optimistic_dad</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.proxy_ndp</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.regen_max_retry</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.router_probe_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.router_solicitation_delay</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.router_solicitation_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.router_solicitations</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.temp_prefered_lft</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.temp_valid_lft</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.conf.default.use_tempaddr</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.icmp.ratelimit</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.ip6frag_high_thresh</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.ip6frag_low_thresh</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.ip6frag_secret_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.ip6frag_time</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.mld_max_msf</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.mld_qrv</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.anycast_delay</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.app_solicit</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.base_reachable_time</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.base_reachable_time_ms</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.delay_first_probe_time</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.gc_stale_time</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.locktime</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.mcast_solicit</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.proxy_delay</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.proxy_qlen</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.retrans_time</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.retrans_time_ms</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.ucast_solicit</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.unres_qlen</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.neigh.{网络接口}.unres_qlen_bytes</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.flush</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.gc_elasticity</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.gc_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.gc_min_interval</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.gc_min_interval_ms</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.gc_thresh</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.gc_timeout</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.max_size</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.min_adv_mss</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.route.mtu_expires</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.ipv6.xfrm6_gc_thresh</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_conntrack_acct</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_conntrack_buckets</td><td width="1100">只读，描述当前系统的 ip_conntrack 的 hash table 大小.</td></tr><tr><td height="54">net.netfilter.nf_conntrack_checksum</td><td width="1100">验证协议是否错误是，是否对协议进行校验和验证<br>0：关闭<br>1：开启</td></tr><tr><td height="18">net.netfilter.nf_conntrack_count</td><td width="1100">内存中 ip_conntrack 结构的数量.</td></tr><tr><td height="18">net.netfilter.nf_conntrack_events</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_conntrack_events_retry_timeout</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_conntrack_expect_max</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_conntrack_generic_timeout</td><td width="1100">通用或未知协议的 conntrack 被设置的超时时间 (每次看到包都会用这值重新更新定时器), 一旦时间到 conntrack 将被回收.(秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_helper</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_conntrack_icmp_timeout</td><td width="1100">icmp 协议的 conntrack 被设置的超时时间，一旦到时 conntrack 将被回收.(秒)</td></tr><tr><td height="36">net.netfilter.nf_conntrack_log_invalid</td><td width="1100">调试时使用，可以指定一个数字，这个数字是内核定义的协议号比如 IPPROTO_TCP 是 6，当指定协议解析时发现一些错误包会打印相关的错误信息到 dmesg 中.<br>最小值 0, 最大值 255，默认不打印.</td></tr><tr><td height="54">net.netfilter.nf_conntrack_max</td><td width="1100">内存中最多 ip_conntrack 结构的数量.</td></tr><tr><td height="54">net.netfilter.nf_conntrack_tcp_be_liberal</td><td width="1100">当开启只有不在 tcp 窗口内的 rst 包被标志为无效，当关闭（默认）所有不在 tcp 窗口中的包都被标志为无效.<br>0：关闭<br>1：开启</td></tr><tr><td height="36">net.netfilter.nf_conntrack_tcp_loose</td><td width="1100">当想追踪一条已经连接的 tcp 会话， 在系统可以假设 sync 和 window 追逐已经开始后要求每个方向必须通过的包的数量.<br>如果为 0，从不追踪一条已经连接的 tcp 会话.</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_max_retrans</td><td width="1100">没有从目的端接收到一个 ack 而进行包重传的次数，一旦达到这限制 nf_conntrack_tcp_timeout_max_retrans 将作为 ip_conntrack 的超时限制.</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_close</td><td width="1100">TCP 处于 close 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_close_wait</td><td width="1100">TCP 处于 close wait 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_established</td><td width="1100">TCP 处于 established 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_fin_wait</td><td width="1100">TCP 处于 fin wait 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_last_ack</td><td width="1100">TCP 处于 last ack 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_max_retrans</td><td width="1100">TCP 处于 max retrans 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_syn_recv</td><td width="1100">TCP 处于 syn recv 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_syn_sent</td><td width="1100">TCP 处于 syn sent 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_time_wait</td><td width="1100">TCP 处于 time wait 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_tcp_timeout_unacknowledged</td><td width="1100">TCP 处于 unacknowledged 状态超时时间 (秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_timestamp</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_conntrack_udp_timeout</td><td width="1100">udp 协议的 conntrack 被设置的超时时间 (每次看到包都会用这值重新更新定时器)，一旦到时 conntrack 将被回收.(秒)</td></tr><tr><td height="18">net.netfilter.nf_conntrack_udp_timeout_stream</td><td width="1100">当看到一些特殊的 udp 传输时 (传输在双向) 设置的 ip_conntrack 超时时间(每次看到包都会用这值重新更新定时器).(秒)</td></tr><tr><td height="18">net.netfilter.nf_log.0</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.1</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.10</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.11</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.12</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.2</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.3</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.4</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.5</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.6</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.7</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.8</td><td width="1100">&nbsp;</td></tr><tr><td height="18">net.netfilter.nf_log.9</td><td width="1100">&nbsp;</td></tr><tr><td height="54">net.nf_conntrack_max</td><td width="1100">内存中最多 ip_conntrack 结构的数量.</td></tr><tr><td height="36">net.unix.max_dgram_qlen</td><td width="1100">允许域套接字中数据包的最大个数，在初始化 unix 域套接字时的默认值.<br>在调用 listen 函数时第二个参数会复盖这个值.</td></tr></tbody></table>

[回到顶部](#_labelTop)

文件系统参数列表 
---------

<table border="0" cellspacing="0" cellpadding="0"><colgroup><col width="289"><col width="1398"></colgroup><tbody><tr><td width="289" height="18">fs.aio-max-nr</td><td width="1398">最大允许 aio 请求数量 (会涉及到数据库的 aio 请求)</td></tr><tr><td height="18">fs.aio-nr</td><td width="1398">当前 aio 请求数量</td></tr><tr><td height="18">fs.binfmt_misc.qemu-alpha</td><td width="1398">binfmt_misc 用于支持当前芯片架构的系统是否支持通过 qemu 进行 chroot 到其他架构的根文件系统中进行操作。</td></tr><tr><td height="18">fs.binfmt_misc.qemu-arm</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-armeb</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-cris</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-i386</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-i486</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-m68k</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-microblaze</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-microblazeel</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-mips</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-mips64</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-mips64el</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-mipsel</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-s390x</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-sh4</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-sh4eb</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-sparc</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-sparc32plus</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.binfmt_misc.qemu-sparc64</td><td width="1398">&nbsp;</td></tr><tr><td height="72">fs.binfmt_misc.register</td><td width="1398"><p>用于注册或修改以上的 binfmt_misc，输入格式是 :name:type:offset:magic:mask:interpreter:flags<br>例：echo ':i386:M::\x7fELF\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03:</p><p>\xff\xff\xff\xff\xff\xfe\xfe\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfb\xff\xff:/bin/em86:' &gt; register</p></td></tr><tr><td height="54">fs.binfmt_misc.status</td><td width="1398">设置 binfmt_misc 开启<br>0：禁止<br>1：开启</td></tr><tr><td height="72">fs.dentry-state</td><td width="1398">保存目录缓存的状态，保存有六个值，只有前三个有效<br>nr_dentry：当前已经分配的目录项数量<br>nr_unused：还没有使用的目录项数量<br>age_limit：当内存紧缺时，延迟多少秒后会回收目录项所占内存</td></tr><tr><td height="72">fs.dir-notify-enable</td><td width="1398">设置是否启用 dnotify，已被 inotify 取代，因为 dnotify 需要您为每个打算监控是否发生改变的目录打开一个文件描述符。当同时监控多个目录时，这会消耗大量的资源，因为有可能达到每个进程的文件描述符限制。并且不允许卸载（unmount）支持的设备<br>0：不使用<br>1：使用</td></tr><tr><td height="18">fs.epoll.max_user_watches</td><td width="1398">IO 复用 epoll 监听文件句柄的数量最大值</td></tr><tr><td height="18">fs.file-max</td><td width="1398">系统中所有进程能够同时打开的文件句柄数量</td></tr><tr><td height="18">fs.file-nr</td><td width="1398">此文件中保存了三个值，分别是：系统中已分配的文件句柄数量&nbsp;&nbsp;&nbsp; 已分配但没有使用的文件句柄数量&nbsp;&nbsp;&nbsp; 最大的文件句柄号</td></tr><tr><td height="18">fs.inode-nr</td><td width="1398">此文件保存了两个值，是：已分配 inode 数&nbsp;&nbsp;&nbsp; 空闲 inode 数</td></tr><tr><td height="18">fs.inode-state</td><td width="1398">此文件保存了三个值，前两个分别表示 已分配 inode 数和空闲 inode 数。第三个是已超出系统最大 inode 值的数量，此时系统需要清除排查 inode 列表</td></tr><tr><td height="54">fs.inotify.max_queued_events</td><td width="1398">inotify 用于监控文件系统事件<br>该文件中的值为调用 inotify_init 函数时分配给 inotify 队列的事件数目的最大值，超出这个值得事件被丢弃，但会触发 IN_Q_OVERFLOW 事件<br>文件系统变化越频繁，这个值就应该越大&nbsp;</td></tr><tr><td height="18">fs.inotify.max_user_instances</td><td width="1398">设置每个用户可以运行的 inotifywait 或 inotifywatch 命令的进程数。</td></tr><tr><td height="18">fs.inotify.max_user_watches</td><td width="1398">设置 inotifywait 或 inotifywatch 命令可以监视的文件数量 (单进程)。</td></tr><tr><td height="54">fs.lease-break-time</td><td width="1398">当进程尝试打开一个被租借锁保护的文件时，该进程会被阻塞，同时，在一定时间内拥有该文件租借锁的进程会收到一个信号。收到信号之后，拥有该文件租借锁的进程会首先更新文件，从而保证了文件内容的一致性，接着，该进程释放这个租借锁。如果拥有租借锁的进程在一定的时间间隔内没有完成工作，内核就会自动删除这个租借锁或者将该锁进行降级，从而允许被阻塞的进程继续工作。<br>此保存租借锁的超时时间 (以秒为单位)</td></tr><tr><td height="54">fs.leases-enable</td><td width="1398">是否启用文件的租借锁<br>1：启用<br>0：不启用</td></tr><tr><td height="36">fs.mqueue.msg_default</td><td width="1398">POSIX 的消息队列<br>此文件保存一个消息队列中消息数量的默认值，如果此值超过 msg_max，则会被设置为 msg_max</td></tr><tr><td height="18">fs.mqueue.msg_max</td><td width="1398">一个消息队列的最大消息数</td></tr><tr><td height="18">fs.mqueue.msgsize_default</td><td width="1398">消息队列中一个消息的默认大小 (以字节为单位)</td></tr><tr><td height="18">fs.mqueue.msgsize_max</td><td width="1398">消息队列中一个消息的最大大小 (以字节为单位)</td></tr><tr><td height="18">fs.mqueue.queues_max</td><td width="1398">系统中允许的消息队列的最大数量</td></tr><tr><td height="18">fs.nfs.idmap_cache_timeout</td><td width="1398">设置 idmapper 缓存项的最大寿命，单位是秒</td></tr><tr><td height="18">fs.nfs.nfs_callback_tcpport</td><td width="1398">设置 NFSv4 回复通道 (callback channel) 监听的 TCP 端口</td></tr><tr><td height="18">fs.nfs.nfs_congestion_kb</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.nfs.nfs_mountpoint_timeout</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.nfs.nlm_grace_period</td><td width="1398">参数设置服务器重新引导后客户机回收 NFSv3 锁和 NFSv4 锁所需的秒数。因此，grace_period 的值可控制 NFSv3 和 NFSv4 的锁定恢复的宽延期长度。</td></tr><tr><td height="18">fs.nfs.nlm_tcpport</td><td width="1398">为 NFS 锁管理器指定 TCP 端口</td></tr><tr><td height="18">fs.nfs.nlm_timeout</td><td width="1398">为 NFS 锁管理器指定默认超时时间，单位是秒。默认值是 10 秒。取值范围在 [3-20]</td></tr><tr><td height="18">fs.nfs.nlm_udpport</td><td width="1398">为 NFS 锁管理器指定 UDP 端口</td></tr><tr><td height="18">fs.nfs.nsm_local_state</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.nfs.nsm_use_hostnames</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.nr_open</td><td width="1398">一个进程最多同时打开的文件句柄数量</td></tr><tr><td height="18">fs.overflowgid</td><td width="1398">Linux 的 GID 为 32 位，但有些文件系统只支持 16 位的 GID，此时若进行写操作会出错；当 GID 超过 65535 时会自动被转换为一个固定值，这个固定值保存在这个文件中</td></tr><tr><td height="18">fs.overflowuid</td><td width="1398">Linux 的 UID 为 32 位，但有些文件系统只支持 16 位的 UID，此时若进行写操作会出错；当 UID 超过 65535 时会自动被转换为一个固定值，这个固定值保存在这个文件中</td></tr><tr><td height="18">fs.pipe-max-size</td><td width="1398">此文件限制非特权程序使用 pipe 时的缓存最大大小 (以字节为单位，最小设置为 4096)</td></tr><tr><td height="54">fs.protected_hardlinks</td><td width="1398">用于限制普通用户建立硬链接<br>0：不限制用户建立硬链接<br>1：限制，如果文件不属于用户，或者用户对此用户没有读写权限，则不能建立硬链接</td></tr><tr><td height="54">fs.protected_symlinks</td><td width="1398">用于限制普通用户建立软链接<br>0：不限制用户建立软链接<br>1：限制，允许用户建立软连接的情况是 软连接所在目录是全局可读写目录或者软连接的 uid 与跟从者的 uid 匹配，又或者目录所有者与软连接所有者匹配</td></tr><tr><td height="18">fs.quota.allocated_dquots</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.quota.cache_hits</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.quota.drops</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.quota.free_dquots</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.quota.lookups</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.quota.reads</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.quota.syncs</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.quota.warnings</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.quota.writes</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fs.suid_dumpable</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fscache.object_max_active</td><td width="1398">&nbsp;</td></tr><tr><td height="18">fscache.operation_max_active</td></tr></tbody></table>